diff -Naur tappas-5.1.0.orig/core/hailo/general/hailo_common.hpp tappas-5.1.0.mod/core/hailo/general/hailo_common.hpp
--- tappas-5.1.0.orig/core/hailo/general/hailo_common.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/general/hailo_common.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -248,7 +248,7 @@
     inline void flatten_hailo_roi(HailoROIPtr roi, HailoROIPtr parent_roi, hailo_object_t filter_type)
     {
         std::vector<HailoObjectPtr> objects = roi->get_objects();
-        for (uint index = 0; index < objects.size(); index++)
+        for (unsigned int index = 0; index < objects.size(); index++)
         {
             if (objects[index]->get_type() == filter_type)
             {
diff -Naur tappas-5.1.0.orig/core/hailo/general/hailo_objects.hpp tappas-5.1.0.mod/core/hailo/general/hailo_objects.hpp
--- tappas-5.1.0.orig/core/hailo/general/hailo_objects.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/general/hailo_objects.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -244,10 +244,10 @@
     /**
      * @brief Remove a HailoObject from the MainObject
      *
-     * @param index  -  uint
+     * @param index  -  unsigned int
      *        The index of the object to remove
      */
-    void remove_object(uint index)
+    void remove_object(unsigned int index)
     {
         std::lock_guard<std::mutex> lock(*mutex);
         m_sub_objects.erase(m_sub_objects.begin() + index);
@@ -505,14 +505,14 @@
 class HailoTileROI : public HailoROI
 {
 protected:
-    uint m_index;
+    unsigned int m_index;
     float m_overlap_x_axis;
     float m_overlap_y_axis;
-    uint m_layer;
+    unsigned int m_layer;
     hailo_tiling_mode_t m_mode;
 
 public:
-    HailoTileROI(HailoBBox bbox, uint index, float overlap_x_axis, float overlap_y_axis, uint layer, hailo_tiling_mode_t mode) : HailoROI(bbox), m_index(index), m_overlap_x_axis(overlap_x_axis), m_overlap_y_axis(overlap_y_axis), m_layer(layer), m_mode(mode){};
+    HailoTileROI(HailoBBox bbox, unsigned int index, float overlap_x_axis, float overlap_y_axis, unsigned int layer, hailo_tiling_mode_t mode) : HailoROI(bbox), m_index(index), m_overlap_x_axis(overlap_x_axis), m_overlap_y_axis(overlap_y_axis), m_layer(layer), m_mode(mode){};
     // Move constructor
     HailoTileROI(HailoTileROI &&other) noexcept : HailoROI(other),
                                                   m_index(other.m_index),
@@ -565,9 +565,9 @@
 
     float get_overlap_x_axis() { return m_overlap_x_axis; }
     float get_overlap_y_axis() { return m_overlap_y_axis; }
-    uint get_index() { return m_index; }
-    uint get_layer() { return m_layer; }
-    uint get_mode() { return m_mode; }
+    unsigned int get_index() { return m_index; }
+    unsigned int get_layer() { return m_layer; }
+    unsigned int get_mode() { return m_mode; }
 };
 using HailoTileROIPtr = std::shared_ptr<HailoTileROI>;
 
diff -Naur tappas-5.1.0.orig/core/hailo/general/hailo_tensors.hpp tappas-5.1.0.mod/core/hailo/general/hailo_tensors.hpp
--- tappas-5.1.0.orig/core/hailo/general/hailo_tensors.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/general/hailo_tensors.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -103,17 +103,17 @@
      * @return uint8_t value of this tensor at the specified place.
      * @note number is quantized.
      */
-    uint8_t get(uint row, uint col, uint channel)
+    uint8_t get(unsigned int row, unsigned int col, unsigned int channel)
     {
-        uint width = m_tensor_meta_info.shape.width;
-        uint features = m_tensor_meta_info.shape.features;
+        unsigned int width = m_tensor_meta_info.shape.width;
+        unsigned int features = m_tensor_meta_info.shape.features;
         int pos = (width * features) * row + features * col + channel;
         return m_data[pos];
     }
-    uint16_t get_uint16(uint row, uint col, uint channel)
+    uint16_t get_uint16(unsigned int row, unsigned int col, unsigned int channel)
     {
-        uint width = m_tensor_meta_info.shape.width;
-        uint features = m_tensor_meta_info.shape.features;
+        unsigned int width = m_tensor_meta_info.shape.width;
+        unsigned int features = m_tensor_meta_info.shape.features;
         int pos = (width * features) * row + features * col + channel;
         uint16_t *data_uint16 = (uint16_t *)m_data;
         return data_uint16[pos];
@@ -127,7 +127,7 @@
      * @param channel The channel of the cell
      * @return float value of this tensor at the specified place (dequantized).
      */
-    float get_full_percision(uint row, uint col, uint channel, bool is_uint16)
+    float get_full_percision(unsigned int row, unsigned int col, unsigned int channel, bool is_uint16)
     {
         if (is_uint16)
             return fix_scale(get_uint16(row, col, channel));
diff -Naur tappas-5.1.0.orig/core/hailo/general/hailo_xtensor.hpp tappas-5.1.0.mod/core/hailo/general/hailo_xtensor.hpp
--- tappas-5.1.0.orig/core/hailo/general/hailo_xtensor.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/general/hailo_xtensor.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -65,7 +65,7 @@
         xt::view(landmarks, xt::all(), 1) = (xt::view(landmarks, xt::all(), 1) - bbox.ymin()) / bbox.height();
         // Create HailoPoint for each point and add it to the vector of points.
         points.reserve(landmarks.shape(0));
-        for (uint i = 0; i < landmarks.shape(0); i++)
+        for (unsigned int i = 0; i < landmarks.shape(0); i++)
         {
             if (has_confidence)
             {
diff -Naur tappas-5.1.0.orig/core/hailo/libs/croppers/vms/vms_croppers.cpp tappas-5.1.0.mod/core/hailo/libs/croppers/vms/vms_croppers.cpp
--- tappas-5.1.0.orig/core/hailo/libs/croppers/vms/vms_croppers.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/croppers/vms/vms_croppers.cpp	2025-11-01 12:19:56.201854833 +0800
@@ -116,7 +116,7 @@
  * @return HailoBBox Adjusted HailoBBox to crop.
  * @note Original algorithm at https://github.com/cleardusk/3DDFA_V2/blob/9fdbea1eb97f762221f71f5c76f08f52296c6704/utils/functions.py#L85
  */
-HailoBBox algorithm_face_crop(uint width, uint height, const HailoBBox &roi, float size_scale = 1.0, float height_offset = 0.0)
+HailoBBox algorithm_face_crop(unsigned int width, unsigned int height, const HailoBBox &roi, float size_scale = 1.0, float height_offset = 0.0)
 {
     // Algorithm
     float old_size = (roi.width() * width + roi.height() * height) / 2;
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/classification/person_attributes.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/classification/person_attributes.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/classification/person_attributes.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/classification/person_attributes.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -48,9 +48,9 @@
                                                                       std::string("person_attributes"));
     }
 
-    uint num_of_attributes = attr_predictions.shape()[0];
+    unsigned int num_of_attributes = attr_predictions.shape()[0];
     // Iterate over the attribute predictions
-    for (uint i = 0; i < num_of_attributes; i++)
+    for (unsigned int i = 0; i < num_of_attributes; i++)
     {
         // Get the confidence
         float confidence = attr_predictions(i);
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/common/nms.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/common/nms.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/common/nms.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/common/nms.hpp	2025-11-01 12:19:56.197854834 +0800
@@ -46,11 +46,11 @@
                   [](HailoDetection a, HailoDetection b)
                   { return a.get_confidence() > b.get_confidence(); });
 
-        for (uint index = 0; index < objects.size(); index++)
+        for (unsigned int index = 0; index < objects.size(); index++)
         {
             if (objects[index].get_confidence() != 0.0f)
             {
-                for (uint jindex = index + 1; jindex < objects.size(); jindex++)
+                for (unsigned int jindex = index + 1; jindex < objects.size(); jindex++)
                 {
                     if ((should_nms_cross_classes || (objects[index].get_class_id() == objects[jindex].get_class_id())) &&
                         objects[jindex].get_confidence() != 0.0f)
@@ -69,7 +69,7 @@
                 }
             }
         }
-        for (uint index = 0; index < objects.size(); index++)
+        for (unsigned int index = 0; index < objects.size(); index++)
         {
             if (objects[index].get_confidence() != 0.0f)
             {
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/face_detection.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/face_detection.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/face_detection.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/face_detection.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -179,20 +179,20 @@
             std::vector<float> anchor_variance_vector;
             std::vector<int> anchor_steps_vector;
 
-            for (uint i = 0; i < config_anchor_variance.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_variance.Size(); i++)
             {
                 anchor_variance_vector.emplace_back(config_anchor_variance[i].GetFloat());
             }
 
-            for (uint i = 0; i < config_anchor_steps.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_steps.Size(); i++)
             {
                 anchor_steps_vector.emplace_back(config_anchor_steps[i].GetInt());
             }
-            for (uint i = 0; i < config_anchor_min_size.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_min_size.Size(); i++)
             {
-                uint anchor_size = config_anchor_min_size[i].Size();
+                unsigned int anchor_size = config_anchor_min_size[i].Size();
                 std::vector<int> anchor;
-                for (uint j = 0; j < anchor_size; j++)
+                for (unsigned int j = 0; j < anchor_size; j++)
                 {
                     anchor.emplace_back(config_anchor_min_size[i].GetArray()[j].GetInt());
                 }
@@ -244,7 +244,7 @@
     // Use the feature map to pre-emptively calculate the size of the anchors.
     int num_anchors = 0;
     xt::xarray<int> feature_area = feature_maps_height * feature_maps_width;
-    for (uint index = 0; index < anchor_min_sizes.size(); index++)
+    for (unsigned int index = 0; index < anchor_min_sizes.size(); index++)
         num_anchors += feature_area(index) * anchor_min_sizes[index].size();
     // Now initialize the anchors to the given size. This way we can fill them in-place
     // instead of concatenating, saving lots of time.
@@ -252,7 +252,7 @@
 
     // Calculate the anchors.
     int counter = 0;
-    for (uint index = 0; index < feature_maps.shape(0); index++)
+    for (unsigned int index = 0; index < feature_maps.shape(0); index++)
     {
         auto current_min_sizes = anchor_min_sizes[index];
         for (int i = 0; i < feature_maps(index, 0); i++)
@@ -352,7 +352,7 @@
     // There is only 1 class in this network (face) so there is no need for label.
     std::string label = "face";
     // Iterate over our results
-    for (uint index = 0; index < scores.size(); ++index)
+    for (unsigned int index = 0; index < scores.size(); ++index)
     {
         confidence = scores(index);                                  // Get the score for this detection
         xmin = detection_boxes(index, 0);                            // Box xmin, relative to image size
@@ -407,7 +407,7 @@
     std::size_t classes_reshaped_size = 0;
 
     // Separate the layers by outs_per_branch steps
-    for (uint i = 0; i < tensors.size(); ++i)
+    for (unsigned int i = 0; i < tensors.size(); ++i)
     {
         // While we're here, adapt the tensor into an xarray of float (dequantized).
         xt::xarray<uint8_t> xdata = common::get_xtensor(tensors[i]);
@@ -447,7 +447,7 @@
     int index = 0;
     std::vector<std::size_t> boxes_shape = {1, boxes_reshaped_size, 4};
     xt::xarray<float> stacked_boxes(boxes_shape);
-    for (uint i = 0; i < box_layers.size(); ++i)
+    for (unsigned int i = 0; i < box_layers.size(); ++i)
     {
         xt::view(stacked_boxes, xt::all(), xt::range(index, index + box_layers[i].shape(1)), xt::all()) = box_layers[i];
         index += box_layers[i].shape(1);
@@ -457,7 +457,7 @@
     // We tell xtensor to explicitly layout the memory by rows, in order to perform math ops faster, e.g. softmax.
     xt::xarray<float, xt::layout_type::row_major> stacked_classes(classes_shape);
     index = 0;
-    for (uint i = 0; i < class_layers.size(); ++i)
+    for (unsigned int i = 0; i < class_layers.size(); ++i)
     {
         xt::view(stacked_classes, xt::all(), xt::range(index, index + class_layers[i].shape(1)), xt::all()) = class_layers[i];
         index += class_layers[i].shape(1);
@@ -471,7 +471,7 @@
     index = 0;
     if (landmarks_layers.size() > 0)
     {
-        for (uint i = 0; i < landmarks_layers.size(); ++i)
+        for (unsigned int i = 0; i < landmarks_layers.size(); ++i)
         {
             xt::view(stacked_landmarks, xt::all(), xt::range(index, index + landmarks_layers[i].shape(1)), xt::all()) = landmarks_layers[i];
             index += landmarks_layers[i].shape(1);
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/hailo_nms_decode.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/hailo_nms_decode.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/hailo_nms_decode.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/hailo_nms_decode.hpp	2025-11-01 12:19:56.197854834 +0800
@@ -21,7 +21,7 @@
     HailoTensorPtr _nms_output_tensor;
     std::map<uint8_t, std::string> labels_dict;
     float _detection_thr;
-    uint _max_boxes;
+    unsigned int _max_boxes;
     bool _filter_by_score;
     const hailo_tensor_nms_shape_t _nms_shape;
 
@@ -60,7 +60,7 @@
     }
 
 public:
-    HailoNMSDecode(HailoTensorPtr tensor, std::map<uint8_t, std::string> &labels_dict, float detection_thr = DEFAULT_THRESHOLD, uint max_boxes = DEFAULT_MAX_BOXES, bool filter_by_score = false)
+    HailoNMSDecode(HailoTensorPtr tensor, std::map<uint8_t, std::string> &labels_dict, float detection_thr = DEFAULT_THRESHOLD, unsigned int max_boxes = DEFAULT_MAX_BOXES, bool filter_by_score = false)
         : _nms_output_tensor(tensor), labels_dict(labels_dict), _detection_thr(detection_thr), _max_boxes(max_boxes), _filter_by_score(filter_by_score), _nms_shape(tensor->nms_shape())
     {
         // making sure that the network's output is indeed an NMS type, by checking the order type value included in the metadata
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/nanodet.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/nanodet.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/nanodet.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/nanodet.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -56,12 +56,12 @@
     
     // Prepare the scores xarray at the size we will fill in in-place
     int total_scores = 0;
-    for (uint i=0; i < tensors.size(); i++) { total_scores += tensors[i]->width() * tensors[i]->height(); }
+    for (unsigned int i=0; i < tensors.size(); i++) { total_scores += tensors[i]->width() * tensors[i]->height(); }
     std::vector<size_t> shape = { (long unsigned int)total_scores, (long unsigned int)num_classes };
     xt::xarray<float> scores(shape);
     int view_index = 0;
 
-    for (uint i=0; i < tensors.size(); i++)
+    for (unsigned int i=0; i < tensors.size(); i++)
     {
         // Extract and dequantize the layer
         auto layer = common::dequantize(common::get_xtensor(tensors[i]), tensors[i]->quant_info().qp_scale, tensors[i]->quant_info().qp_zp);
@@ -112,7 +112,7 @@
     int instance_index = 0;
     float confidence = 0.0;
     std::string label;
-    for (uint i=0; i < raw_boxes.size(); i++)
+    for (unsigned int i=0; i < raw_boxes.size(); i++)
     {
         strided_width = network_dims[0] / strides[i];
         strided_height = network_dims[1] / strides[i];
@@ -142,7 +142,7 @@
         auto distance_view = xt::concatenate(xt::xtuple(distance_view1, distance_view2), 1);
         auto decoded_boxes = centers + distance_view;
 
-        for (uint j=0; j < decoded_boxes.shape(0); j++)
+        for (unsigned int j=0; j < decoded_boxes.shape(0); j++)
         {
             HailoBBox bbox(decoded_boxes(j, 0) / network_dims[0],
                            decoded_boxes(j, 1) / network_dims[1],
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/scrfd.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/scrfd.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/scrfd.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/scrfd.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -162,20 +162,20 @@
             std::vector<float> anchor_variance_vector;
             std::vector<int> anchor_steps_vector;
 
-            for (uint i = 0; i < config_anchor_variance.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_variance.Size(); i++)
             {
                 anchor_variance_vector.emplace_back(config_anchor_variance[i].GetFloat());
             }
 
-            for (uint i = 0; i < config_anchor_steps.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_steps.Size(); i++)
             {
                 anchor_steps_vector.emplace_back(config_anchor_steps[i].GetInt());
             }
-            for (uint i = 0; i < config_anchor_min_size.Size(); i++)
+            for (unsigned int i = 0; i < config_anchor_min_size.Size(); i++)
             {
-                uint anchor_size = config_anchor_min_size[i].Size();
+                unsigned int anchor_size = config_anchor_min_size[i].Size();
                 std::vector<int> anchor;
-                for (uint j = 0; j < anchor_size; j++)
+                for (unsigned int j = 0; j < anchor_size; j++)
                 {
                     anchor.emplace_back(config_anchor_min_size[i].GetArray()[j].GetInt());
                 }
@@ -222,7 +222,7 @@
 
     // Initialize the anchors to the given size. This way we can fill them in-place
     // instead of concatenating, saving lots of time. 
-    for (uint index = 0; index < anchor_min_sizes.size(); index++)
+    for (unsigned int index = 0; index < anchor_min_sizes.size(); index++)
     {
         width = image_width / anchor_steps[index];
         height = image_height / anchor_steps[index];
@@ -232,7 +232,7 @@
     xt::xarray<float> anchors = xt::zeros<float>({total_anchors, 4});
 
     int anchor_range = 0;
-    for (uint index = 0; index < anchor_min_sizes.size(); index++)
+    for (unsigned int index = 0; index < anchor_min_sizes.size(); index++)
     {
         // First build a meshgrid of centers (x,y) for the anchors
         int width = image_width / anchor_steps[index];
@@ -341,7 +341,7 @@
     std::vector<xt::xarray<float>> decoded_landmarks(LANDMARKS.size());
 
     int steps = 0;
-    for (uint i = 0; i < CLASSES.size(); ++i)
+    for (unsigned int i = 0; i < CLASSES.size(); ++i)
     {
         auto boxes_scores_landmarks = detect_decode_branch(tensors,
                                                            boxes_quant[i],
@@ -375,9 +375,9 @@
     // There is only 1 class in this network (face) so there is no need for label.
     std::string label = "face";
     // Iterate over our results
-    for (uint i = 0; i < CLASSES.size(); ++i)
+    for (unsigned int i = 0; i < CLASSES.size(); ++i)
     {
-        for (uint index = 0; index < scores[i].size(); ++index)
+        for (unsigned int index = 0; index < scores[i].size(); ++index)
         {
             confidence = scores[i](index);                                  // Get the score for this detection
             xmin = detection_boxes[i](index, 0);                            // Box xmin, relative to image size
@@ -418,7 +418,7 @@
     std::vector<xt::xarray<uint8_t>> class_layers_quant;
     std::vector<xt::xarray<uint8_t>> landmarks_layers_quant;
 
-    for (uint i = 0; i < BOXES.size(); ++i)
+    for (unsigned int i = 0; i < BOXES.size(); ++i)
     {
         // Extract the boxes
         xt::xarray<uint8_t> xdata_boxes = common::get_xtensor(tensors_by_name[BOXES[i]]);
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_hailortpp.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_hailortpp.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_hailortpp.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_hailortpp.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -77,7 +77,7 @@
 
             // parse labels
             auto labels = doc_config_json["labels"].GetArray();
-            uint i = 0;
+            unsigned int i = 0;
             for (auto &v : labels)
             {
                 params->labels.insert(std::pair<std::uint8_t, std::string>(i, v.GetString()));
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_hailortpp.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_hailortpp.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_hailortpp.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_hailortpp.hpp	2025-11-01 12:19:56.197854834 +0800
@@ -13,11 +13,11 @@
 public:
     std::map<std::uint8_t, std::string> labels;
     float detection_threshold;
-    uint max_boxes;
+    unsigned int max_boxes;
     bool filter_by_score=false;
     YoloParamsNMS(std::map<uint8_t, std::string> dataset = std::map<uint8_t, std::string>(),
                   float detection_threshold = 0.3f,
-                  uint max_boxes = 200)
+                  unsigned int max_boxes = 200)
         : labels(dataset),
           detection_threshold(detection_threshold), 
           max_boxes(max_boxes) {}
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_output.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_output.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_output.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_output.cpp	2025-11-01 12:19:56.197854834 +0800
@@ -7,11 +7,11 @@
 #include <algorithm>
 #include "yolo_output.hpp"
 
-std::pair<uint, float> YoloOutputLayer::get_class(uint row, uint col, uint anchor)
+std::pair<unsigned int, float> YoloOutputLayer::get_class(unsigned int row, unsigned int col, unsigned int anchor)
 {
-    uint cls_prob, prob_max = 0;
-    uint selected_class_id = 1;
-    for (uint class_id = label_offset; class_id <= _num_classes; class_id++)
+    unsigned int cls_prob, prob_max = 0;
+    unsigned int selected_class_id = 1;
+    for (unsigned int class_id = label_offset; class_id <= _num_classes; class_id++)
     {
         cls_prob = get_class_prob(row, col, anchor, class_id);
         if (cls_prob > prob_max)
@@ -20,12 +20,12 @@
             prob_max = cls_prob;
         }
     }
-    return std::pair<uint, float>(selected_class_id, get_class_conf(prob_max));
+    return std::pair<unsigned int, float>(selected_class_id, get_class_conf(prob_max));
 }
 
-float YoloOutputLayer::get_confidence(uint row, uint col, uint anchor)
+float YoloOutputLayer::get_confidence(unsigned int row, unsigned int col, unsigned int anchor)
 {
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor + CONF_CHANNEL_OFFSET;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor + CONF_CHANNEL_OFFSET;
     float confidence = _tensor->get_full_percision(row, col, channel, _is_uint16);
     if (_perform_sigmoid)
         confidence = sigmoid(confidence);
@@ -38,16 +38,16 @@
     return 1.0f / (1.0f + expf(-x));
 }
 
-uint YoloOutputLayer::get_class_prob(uint row, uint col, uint anchor, uint class_id)
+unsigned int YoloOutputLayer::get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int class_id)
 {
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor + CLASS_CHANNEL_OFFSET + class_id - 1;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor + CLASS_CHANNEL_OFFSET + class_id - 1;
     if (_is_uint16)
         return _tensor->get_uint16(row, col, channel);
     else
         return _tensor->get(row, col, channel);
 }
 
-float Yolov5OL::get_class_conf(uint prob_max)
+float Yolov5OL::get_class_conf(unsigned int prob_max)
 {
     float conf = _tensor->fix_scale(prob_max);
     if (_perform_sigmoid)
@@ -55,25 +55,25 @@
     return conf;
 }
 
-std::pair<float, float> Yolov5OL::get_center(uint row, uint col, uint anchor)
+std::pair<float, float> Yolov5OL::get_center(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float x, y = 0.0f;
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor;
     x = (_tensor->get_full_percision(row, col, channel, _is_uint16) * 2.0f - 0.5f + col) / _width;
     y = (_tensor->get_full_percision(row, col, channel + 1, _is_uint16) * 2.0f - 0.5f + row) / _height;
     return std::pair<float, float>(x, y);
 }
 
-std::pair<float, float> Yolov5OL::get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height)
+std::pair<float, float> Yolov5OL::get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height)
 {
     float w, h = 0.0f;
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
     w = pow(2.0f * _tensor->get_full_percision(row, col, channel, _is_uint16), 2.0f) * _anchors[anchor * 2] / image_width;
     h = pow(2.0f * _tensor->get_full_percision(row, col, channel + 1, _is_uint16), 2.0f) * _anchors[anchor * 2 + 1] / image_height;
     return std::pair<float, float>(w, h);
 }
 
-float Yolov3OL::get_class_conf(uint prob_max)
+float Yolov3OL::get_class_conf(unsigned int prob_max)
 {
     float conf = _tensor->fix_scale(prob_max);
     if (_perform_sigmoid)
@@ -81,25 +81,25 @@
     return conf;
 }
 
-std::pair<float, float> Yolov3OL::get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height)
+std::pair<float, float> Yolov3OL::get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height)
 {
     float w, h = 0.0f;
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
     w = expf(_tensor->get_full_percision(row, col, channel, _is_uint16)) * _anchors[anchor * 2] / image_width;
     h = expf(_tensor->get_full_percision(row, col, channel + 1, _is_uint16)) * _anchors[anchor * 2 + 1] / image_height;
     return std::pair<float, float>(w, h);
 }
 
-std::pair<float, float> Yolov3OL::get_center(uint row, uint col, uint anchor)
+std::pair<float, float> Yolov3OL::get_center(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float x, y = 0.0f;
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor;
     x = (sigmoid(_tensor->get_full_percision(row, col, channel, _is_uint16)) + col) / _width;
     y = (sigmoid(_tensor->get_full_percision(row, col, channel + 1, _is_uint16)) + row) / _height;
     return std::pair<float, float>(x, y);
 }
 
-float Yolov4OL::get_confidence(uint row, uint col, uint anchor)
+float Yolov4OL::get_confidence(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float confidence = _obj->get_full_percision(row, col, anchor, _is_uint16);
     if (_perform_sigmoid)
@@ -107,13 +107,13 @@
     return confidence;
 }
 
-uint Yolov4OL::get_class_prob(uint row, uint col, uint anchor, uint class_id)
+unsigned int Yolov4OL::get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int class_id)
 {
-    uint channel = _num_classes * anchor + class_id - 1;
+    unsigned int channel = _num_classes * anchor + class_id - 1;
     return _cls->get(row, col, channel);
 }
 
-float Yolov4OL::get_class_conf(uint prob_max)
+float Yolov4OL::get_class_conf(unsigned int prob_max)
 {
     float class_conf = _cls->fix_scale(prob_max);
     if (_perform_sigmoid)
@@ -121,11 +121,11 @@
     return class_conf;
 }
 
-std::pair<float, float> Yolov4OL::get_center(uint row, uint col, uint anchor)
+std::pair<float, float> Yolov4OL::get_center(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float x;
     float y;
-    uint channel = (_center->features() / NUM_ANCHORS) * anchor;
+    unsigned int channel = (_center->features() / NUM_ANCHORS) * anchor;
     if (_perform_sigmoid) {
         x = (sigmoid(_center->get_full_percision(row, col, channel, _is_uint16)) * SCALE_XY - 0.5f * (SCALE_XY - 1) + col) / _width;
         y = (sigmoid(_center->get_full_percision(row, col, channel + 1, _is_uint16)) * SCALE_XY - 0.5f * (SCALE_XY - 1) + row) / _height;
@@ -137,24 +137,24 @@
     return std::pair<float, float>(x, y);
 }
 
-std::pair<float, float> Yolov4OL::get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height)
+std::pair<float, float> Yolov4OL::get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height)
 {
     float w, h = 0.0f;
-    uint channel = (_scale->features() / NUM_ANCHORS) * anchor;
+    unsigned int channel = (_scale->features() / NUM_ANCHORS) * anchor;
     w = expf(_scale->get_full_percision(row, col, channel, _is_uint16)) * _anchors[anchor * 2] / image_width;
     h = expf(_scale->get_full_percision(row, col, channel + 1, _is_uint16)) * _anchors[anchor * 2 + 1] / image_height;
     return std::pair<float, float>(w, h);
 }
 
-std::pair<float, float> TinyYolov4OL::get_center(uint row, uint col, uint anchor)
+std::pair<float, float> TinyYolov4OL::get_center(unsigned int row, unsigned int col, unsigned int anchor)
 {
-    uint channel = (_tensor->features() / NUM_ANCHORS) * anchor;
+    unsigned int channel = (_tensor->features() / NUM_ANCHORS) * anchor;
     float x = (sigmoid(_tensor->get_full_percision(row, col, channel, _is_uint16)) * SCALE_XY - 0.5f * (SCALE_XY - 1) + col) / _width;
     float y = (sigmoid(_tensor->get_full_percision(row, col, channel + 1, _is_uint16)) * SCALE_XY - 0.5f * (SCALE_XY - 1) + row) / _height;
     return std::pair<float, float>(x, y);
 }
 
-float TinyYolov4OL::get_class_conf(uint prob_max)
+float TinyYolov4OL::get_class_conf(unsigned int prob_max)
 {
     float conf = _tensor->fix_scale(prob_max);
     if (_perform_sigmoid)
@@ -162,16 +162,16 @@
     return conf;
 }
 
-std::pair<float, float> TinyYolov4OL::get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height)
+std::pair<float, float> TinyYolov4OL::get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height)
 {
     float w, h = 0.0f;
-    uint channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
+    unsigned int channel = _tensor->features() / NUM_ANCHORS * anchor + NUM_CENTERS;
     w = expf(_tensor->get_full_percision(row, col, channel, _is_uint16)) * _anchors[anchor * 2] / image_width;
     h = expf(_tensor->get_full_percision(row, col, channel + 1, _is_uint16)) * _anchors[anchor * 2 + 1] / image_height;
     return std::pair<float, float>(w, h);
 }
 
-float YoloXOL::get_confidence(uint row, uint col, uint anchor)
+float YoloXOL::get_confidence(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float confidence = _obj->get_full_percision(row, col, 0, _is_uint16);
     if (_perform_sigmoid)
@@ -179,12 +179,12 @@
     return confidence;
 }
 
-uint YoloXOL::get_class_prob(uint row, uint col, uint anchor, uint class_id)
+unsigned int YoloXOL::get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int class_id)
 {
     return _cls->get(row, col, class_id - 1);
 }
 
-float YoloXOL::get_class_conf(uint prob_max)
+float YoloXOL::get_class_conf(unsigned int prob_max)
 {
     float conf = _cls->fix_scale(prob_max);
     if (_perform_sigmoid)
@@ -192,7 +192,7 @@
     return conf;
 }
 
-std::pair<float, float> YoloXOL::get_center(uint row, uint col, uint anchor)
+std::pair<float, float> YoloXOL::get_center(unsigned int row, unsigned int col, unsigned int anchor)
 {
     float x, y = 0.0f;
     x = (_bbox->get_full_percision(row, col, 0, _is_uint16) + col) / _width;
@@ -200,7 +200,7 @@
     return std::pair<float, float>(x, y);
 }
 
-std::pair<float, float> YoloXOL::get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height)
+std::pair<float, float> YoloXOL::get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height)
 {
     float w, h = 0.0f;
     w = expf(_bbox->get_full_percision(row, col, 2, _is_uint16)) / _width;
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_output.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_output.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_output.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_output.hpp	2025-11-01 12:19:56.197854834 +0800
@@ -13,15 +13,15 @@
 class YoloOutputLayer
 {
 public:
-    static const uint NUM_ANCHORS = 3;
-    static const uint NUM_CENTERS = 2;
-    static const uint NUM_SCALES = 2;
-    static const uint NUM_CONF = 1;
-    static const uint CONF_CHANNEL_OFFSET = NUM_CENTERS + NUM_SCALES;
-    static const uint CLASS_CHANNEL_OFFSET = CONF_CHANNEL_OFFSET + NUM_CONF;
-    YoloOutputLayer(uint width,
-                    uint height,
-                    uint num_of_classes,
+    static const unsigned int NUM_ANCHORS = 3;
+    static const unsigned int NUM_CENTERS = 2;
+    static const unsigned int NUM_SCALES = 2;
+    static const unsigned int NUM_CONF = 1;
+    static const unsigned int CONF_CHANNEL_OFFSET = NUM_CENTERS + NUM_SCALES;
+    static const unsigned int CLASS_CHANNEL_OFFSET = CONF_CHANNEL_OFFSET + NUM_CONF;
+    YoloOutputLayer(unsigned int width,
+                    unsigned int height,
+                    unsigned int num_of_classes,
                     std::vector<int> anchors,
                     bool perform_sigmoid,
                     int label_offset,
@@ -36,9 +36,9 @@
                                                        _tensor(tensor){};
     virtual ~YoloOutputLayer() = default;
 
-    uint _width;
-    uint _height;
-    uint _num_classes;
+    unsigned int _width;
+    unsigned int _height;
+    unsigned int _num_classes;
     std::vector<int> _anchors;
     int label_offset;
 
@@ -48,9 +48,9 @@
      * @param row
      * @param col
      * @param anchor
-     * @return std::pair<uint, float> class id and class probability.
+     * @return std::pair<unsigned int, float> class id and class probability.
      */
-    std::pair<uint, float> get_class(uint row, uint col, uint anchor);
+    std::pair<unsigned int, float> get_class(unsigned int row, unsigned int col, unsigned int anchor);
     /**
      * @brief Get the confidence object
      *
@@ -59,7 +59,7 @@
      * @param anchor
      * @return float
      */
-    virtual float get_confidence(uint row, uint col, uint anchor);
+    virtual float get_confidence(unsigned int row, unsigned int col, unsigned int anchor);
     /**
      * @brief Get the center object
      *
@@ -68,7 +68,7 @@
      * @param anchor
      * @return std::pair<float, float> pair of x,y of the center of this prediction.
      */
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor) = 0;
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor) = 0;
     /**
      * @brief Get the shape object
      *
@@ -79,7 +79,7 @@
      * @param image_height
      * @return std::pair<float, float> pair of w,h of the shape of this prediction.
      */
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height) = 0;
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height) = 0;
 
 protected:
     bool _perform_sigmoid;
@@ -91,17 +91,17 @@
      *
      * @param anchor
      * @param channel
-     * @return uint
+     * @return unsigned int
      */
-    virtual uint get_class_prob(uint row, uint col, uint anchor, uint class_id);
+    virtual unsigned int get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int class_id);
     /**
      * @brief Get the class conf object
      *
      * @param prob_max
      * @return float
      */
-    virtual float get_class_conf(uint prob_max) = 0;
-    static uint num_classes(uint channels)
+    virtual float get_class_conf(unsigned int prob_max) = 0;
+    static unsigned int num_classes(unsigned int channels)
     {
         return (channels / NUM_ANCHORS) - CLASS_CHANNEL_OFFSET;
     }
@@ -123,9 +123,9 @@
                                                is_uint16,
                                                tensor){};
 
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor);
-    virtual float get_class_conf(uint prob_max);
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height);
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual float get_class_conf(unsigned int prob_max);
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height);
 };
 
 class TinyYolov4OL : public YoloOutputLayer
@@ -144,9 +144,9 @@
                                                    label_offset,
                                                    is_uint16,
                                                    tensor){};
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor);
-    virtual float get_class_conf(uint prob_max);
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height);
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual float get_class_conf(unsigned int prob_max);
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height);
 };
 
 class Yolov4OL : public YoloOutputLayer
@@ -162,7 +162,7 @@
              bool perform_sigmoid,
              bool is_uint16) : YoloOutputLayer(cls->width(),
                                                      cls->height(),
-                                                     (uint)(cls->features() / NUM_ANCHORS),
+                                                     (unsigned int)(cls->features() / NUM_ANCHORS),
                                                      anchors,
                                                      perform_sigmoid,
                                                      label_offset,
@@ -171,11 +171,11 @@
                                      _scale(scale),
                                      _obj(obj),
                                      _cls(cls){};
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor);
-    virtual float get_confidence(uint row, uint col, uint anchor);
-    virtual uint get_class_prob(uint row, uint col, uint anchor, uint channel);
-    virtual float get_class_conf(uint prob_max);
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height);
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual float get_confidence(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual unsigned int get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int channel);
+    virtual float get_class_conf(unsigned int prob_max);
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height);
 
 protected:
     HailoTensorPtr _center;
@@ -199,22 +199,22 @@
                                                label_offset,
                                                is_uint16,
                                                tensor){};
-    virtual float get_class_conf(uint prob_max);
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor);
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height);
+    virtual float get_class_conf(unsigned int prob_max);
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height);
 };
 
 class YoloXOL : public YoloOutputLayer
 {
 public:
-    static const uint NUM_ANCHORS = 1;
+    static const unsigned int NUM_ANCHORS = 1;
     YoloXOL(HailoTensorPtr bbox,
             HailoTensorPtr obj,
             HailoTensorPtr cls,
             int label_offset,
             bool is_uint16) : YoloOutputLayer(cls->width(),
                                                 cls->height(),
-                                                (uint)(cls->features()),
+                                                (unsigned int)(cls->features()),
                                                 {},
                                                 false,
                                                 label_offset,
@@ -222,11 +222,11 @@
                                 _bbox(bbox),
                                 _obj(obj),
                                 _cls(cls){};
-    virtual float get_confidence(uint row, uint col, uint anchor);
-    virtual uint get_class_prob(uint row, uint col, uint anchor, uint channel);
-    virtual float get_class_conf(uint prob_max);
-    virtual std::pair<float, float> get_center(uint row, uint col, uint anchor);
-    virtual std::pair<float, float> get_shape(uint row, uint col, uint anchor, uint image_width, uint image_height);
+    virtual float get_confidence(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual unsigned int get_class_prob(unsigned int row, unsigned int col, unsigned int anchor, unsigned int channel);
+    virtual float get_class_conf(unsigned int prob_max);
+    virtual std::pair<float, float> get_center(unsigned int row, unsigned int col, unsigned int anchor);
+    virtual std::pair<float, float> get_shape(unsigned int row, unsigned int col, unsigned int anchor, unsigned int image_width, unsigned int image_height);
 
 protected:
     HailoTensorPtr _bbox;
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_postprocess.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_postprocess.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_postprocess.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_postprocess.cpp	2025-11-01 12:19:56.193854836 +0800
@@ -30,11 +30,11 @@
 {
 protected:
     std::vector<std::shared_ptr<YoloOutputLayer>> _layers;
-    uint _max_boxes;
+    unsigned int _max_boxes;
     float _detection_thr;
     float _iou_thr;
-    uint m_image_width;
-    uint m_image_height;
+    unsigned int m_image_width;
+    unsigned int m_image_height;
     std::map<uint8_t, std::string> m_dataset;
 
 public:
@@ -42,7 +42,7 @@
     YoloPost(std::map<uint8_t, std::string> dataset,
              float detection_threshold,
              float iou_threshold,
-             uint max_boxes)
+             unsigned int max_boxes)
         : _max_boxes(max_boxes), _detection_thr(detection_threshold),
           _iou_thr(iou_threshold), m_dataset(dataset){};
 
@@ -65,7 +65,7 @@
         return objects;
     }
 
-    uint get_num_classes()
+    unsigned int get_num_classes()
     {
         return _layers[0]->_num_classes;
     }
@@ -84,14 +84,14 @@
 void YoloPost::extract_boxes(std::shared_ptr<YoloOutputLayer> layer,
                              std::vector<HailoDetection> &objects)
 {
-    uint class_id = 0;
+    unsigned int class_id = 0;
     float x, y, h, w, confidence, class_confidence = 0.0f;
     float xmin, ymin = 0.0f;
-    for (uint row = 0; row < layer->_height; ++row)
+    for (unsigned int row = 0; row < layer->_height; ++row)
     {
-        for (uint col = 0; col < layer->_width; ++col)
+        for (unsigned int col = 0; col < layer->_width; ++col)
         {
-            for (uint anchor = 0; anchor < layer->NUM_ANCHORS; ++anchor)
+            for (unsigned int anchor = 0; anchor < layer->NUM_ANCHORS; ++anchor)
             {
                 confidence = layer->get_confidence(row, col, anchor);
                 if (confidence < _detection_thr)
@@ -530,7 +530,7 @@
 
             // parse labels
             auto labels = doc_config_json["labels"].GetArray();
-            uint i = 0;
+            unsigned int i = 0;
             for (auto &v : labels)
             {
                 params->labels.insert(std::pair<std::uint8_t, std::string>(i, v.GetString()));
@@ -539,11 +539,11 @@
             // parse anchors
             auto config_anchors = doc_config_json["anchors"].GetArray();
             std::vector<std::vector<int>> anchors_vec;
-            for (uint j = 0; j < config_anchors.Size(); j++)
+            for (unsigned int j = 0; j < config_anchors.Size(); j++)
             {
-                uint size = config_anchors[j].GetArray().Size();
+                unsigned int size = config_anchors[j].GetArray().Size();
                 std::vector<int> anchor;
-                for (uint k = 0; k < size; k++)
+                for (unsigned int k = 0; k < size; k++)
                 {
                     anchor.push_back(config_anchors[j].GetArray()[k].GetInt());
                 }
@@ -569,7 +569,7 @@
     }
     return params;
 }
-void YoloParams::check_params_logic(uint num_classes_tensors)
+void YoloParams::check_params_logic(unsigned int num_classes_tensors)
 {
     if (labels.size() - 1 != num_classes_tensors)
     {
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_postprocess.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_postprocess.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/detection/yolo_postprocess.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/detection/yolo_postprocess.hpp	2025-11-01 12:19:56.197854834 +0800
@@ -16,13 +16,13 @@
     float iou_threshold;
     float detection_threshold;
     std::map<std::uint8_t, std::string> labels;
-    uint num_classes;
-    uint max_boxes;
+    unsigned int num_classes;
+    unsigned int max_boxes;
     std::vector<std::vector<int>> anchors_vec;
     std::string output_activation; // can be "none" or "sigmoid"
     int label_offset;
     YoloParams() : iou_threshold(0.45f), detection_threshold(0.3f), output_activation("none"), label_offset(1) {}
-    void check_params_logic(uint num_classes_tensors);
+    void check_params_logic(unsigned int num_classes_tensors);
 };
 
 class Yolov3Params : public YoloParams
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/instance_segmentation/mask_decoding.hpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/instance_segmentation/mask_decoding.hpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/instance_segmentation/mask_decoding.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/instance_segmentation/mask_decoding.hpp	2025-11-01 12:19:56.193854836 +0800
@@ -29,7 +29,7 @@
 xt::xarray<float> dot_product_axis_2(xt::xarray<float, xt::layout_type::row_major> matrix_1,
                                      xt::xarray<float, xt::layout_type::row_major> matrix_2)
 {
-    uint axis_length = matrix_1.shape(2);
+    unsigned int axis_length = matrix_1.shape(2);
     if (axis_length != matrix_2.shape(0))
     {
         throw std::invalid_argument("dot_product_axis_2 error: axis don't match!");
@@ -37,12 +37,12 @@
     float row_sum;
     xt::xarray<float>::shape_type shape = {matrix_1.shape(0), matrix_1.shape(1)};
     xt::xarray<float, xt::layout_type::row_major> product_matrix(shape);
-    for (uint i = 0; i < matrix_1.shape(0); ++i)
+    for (unsigned int i = 0; i < matrix_1.shape(0); ++i)
     {
-        for (uint j = 0; j < matrix_1.shape(1); ++j)
+        for (unsigned int j = 0; j < matrix_1.shape(1); ++j)
         {
             row_sum = 0.0;
-            for (uint k = 0; k < axis_length; ++k)
+            for (unsigned int k = 0; k < axis_length; ++k)
             {
                 row_sum += matrix_1(i, j, k) * matrix_2(k);
             }
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/instance_segmentation/yolov5seg.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/instance_segmentation/yolov5seg.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/instance_segmentation/yolov5seg.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/instance_segmentation/yolov5seg.cpp	2025-11-01 12:19:56.193854836 +0800
@@ -82,13 +82,13 @@
  */
 auto filter_above_threshold(auto &all_scores, auto &is_object_threshold, const float score_threshold, const uint16_t threshold_quantized, const float qp_zp, const float qp_scale)
 {
-    std::vector<uint> indices;
+    std::vector<unsigned int> indices;
     std::vector<float> scores;
-    std::vector<uint> classes;
+    std::vector<unsigned int> classes;
     int this_index;
     float conf_deq, is_object_deq;
     uint16_t is_object;
-    for (uint i = 0; i < is_object_threshold.size(); i++)
+    for (unsigned int i = 0; i < is_object_threshold.size(); i++)
     {
         // first check if the object parameter is bigger than threshold
         is_object = is_object_threshold(i, 0);
@@ -106,7 +106,7 @@
         }
     }
     }
-    return std::tuple<std::vector<uint>, std::vector<float>, std::vector<uint>>(std::move(indices), std::move(scores), std::move(classes));
+    return std::tuple<std::vector<unsigned int>, std::vector<float>, std::vector<unsigned int>>(std::move(indices), std::move(scores), std::move(classes));
 }
 
 /*
@@ -124,7 +124,7 @@
     int class_index;
     float confidence, w, h, x, y = 0.0;
     std::vector<HailoDetection> objects;
-    for (uint i = 0; i < scores_vec.size(); i++)
+    for (unsigned int i = 0; i < scores_vec.size(); i++)
     {
         // Get the box parameters for this box
         x = (xy(i, 0)) / input_width;
@@ -165,9 +165,9 @@
     // quantize the score threshold + "undecode" it (do inverse of sigmoid), to avoid doing dequantization and decoding on all class scores
     uint16_t threshold_quantized = quant(inverse_sigmoid(score_threshold), qp_zp, qp_scale);
     auto filtered = filter_above_threshold(all_scores, all_is_object, score_threshold, threshold_quantized, qp_zp, qp_scale);
-    std::vector<uint> indices = std::get<0>(filtered);
+    std::vector<unsigned int> indices = std::get<0>(filtered);
     std::vector<float> scores_vec = std::get<1>(filtered);
-    std::vector<uint> classes_vec = std::get<2>(filtered);
+    std::vector<unsigned int> classes_vec = std::get<2>(filtered);
 
     // filter xy and grid
     auto xy = xt::view(all_decoded, xt::all(), xt::range(_, 2));
@@ -317,11 +317,11 @@
             // parse anchors
             auto config_anchors = doc_config_json["anchors"].GetArray();
             std::vector<xt::xarray<float>> anchors_vec;
-            for (uint j = 0; j < config_anchors.Size(); j++)
+            for (unsigned int j = 0; j < config_anchors.Size(); j++)
             {
-                uint size = config_anchors[j].GetArray().Size();
+                unsigned int size = config_anchors[j].GetArray().Size();
                 std::vector<float> anchor;
-                for (uint k = 0; k < size; k++)
+                for (unsigned int k = 0; k < size; k++)
                 {
                     anchor.push_back(config_anchors[j].GetArray()[k].GetFloat());
                 }
@@ -333,7 +333,7 @@
             // parse outputs_size
             auto config_outputs_size = doc_config_json["outputs_size"].GetArray();
             std::vector<int> outputs_size_vec;
-            for (uint j = 0; j < config_outputs_size.Size(); j++)
+            for (unsigned int j = 0; j < config_outputs_size.Size(); j++)
             {
                 outputs_size_vec.push_back(config_outputs_size[j].GetInt());
             }
@@ -342,7 +342,7 @@
             // parse outputs_name
             auto config_outputs_name = doc_config_json["outputs_name"].GetArray();
             std::vector<std::string> outputs_name_vec;
-            for (uint j = 0; j < config_outputs_name.Size(); j++)
+            for (unsigned int j = 0; j < config_outputs_name.Size(); j++)
             {
                 outputs_name_vec.push_back(config_outputs_name[j].GetString());
             }
@@ -351,7 +351,7 @@
             // parse input_shape
             auto config_input_shape = doc_config_json["input_shape"].GetArray();
             std::vector<int> input_shape_vec;
-            for (uint j = 0; j < config_input_shape.Size(); j++)
+            for (unsigned int j = 0; j < config_input_shape.Size(); j++)
             {
                 input_shape_vec.push_back(config_input_shape[j].GetInt());
             }
@@ -360,7 +360,7 @@
             // parse strides
             auto config_strides = doc_config_json["strides"].GetArray();
             std::vector<int> strides_vec;
-            for (uint j = 0; j < config_strides.Size(); j++)
+            for (unsigned int j = 0; j < config_strides.Size(); j++)
             {
                 strides_vec.push_back(config_strides[j].GetInt());
             }
@@ -375,7 +375,7 @@
     std::vector<xt::xarray<float>> anchor_grids;
     int num_anchors = 0;
     // create grid and anchor grid
-    for (uint index = 0; index < outputs_size.size(); index++)
+    for (unsigned int index = 0; index < outputs_size.size(); index++)
     {
         anchors[index] /= strides[index];
         num_anchors = floor(anchors[index].size() / 2);
diff -Naur tappas-5.1.0.orig/core/hailo/libs/postprocesses/pose_estimation/yolov8pose_postprocess.cpp tappas-5.1.0.mod/core/hailo/libs/postprocesses/pose_estimation/yolov8pose_postprocess.cpp
--- tappas-5.1.0.orig/core/hailo/libs/postprocesses/pose_estimation/yolov8pose_postprocess.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/libs/postprocesses/pose_estimation/yolov8pose_postprocess.cpp	2025-11-01 12:19:56.193854836 +0800
@@ -52,7 +52,7 @@
     auto score = keypoint_coordinates_and_score.second;
     
     // Filter keypoints
-    for (uint i = 0; i < score.shape(0); i++){
+    for (unsigned int i = 0; i < score.shape(0); i++){
         if (score(i,0) > joint_threshold) {
             keypoints.push_back(KeyPt({coordinates(i, 0) / network_dims[0], coordinates(i, 1) / network_dims[1], score(i,0)}));
         }
@@ -106,11 +106,11 @@
 
     std::vector<Decodings> decodings_after_nms;
 
-    for (uint index = 0; index < decodings.size(); index++)
+    for (unsigned int index = 0; index < decodings.size(); index++)
     {
         if (decodings[index].detection_box.get_confidence() != 0.0f)
         {
-            for (uint jindex = index + 1; jindex < decodings.size(); jindex++)
+            for (unsigned int jindex = index + 1; jindex < decodings.size(); jindex++)
             {
                 if ((should_nms_cross_classes || (decodings[index].detection_box.get_class_id() == decodings[jindex].detection_box.get_class_id())) &&
                     decodings[jindex].detection_box.get_confidence() != 0.0f)
@@ -129,7 +129,7 @@
             }
         }
     }
-    for (uint index = 0; index < decodings.size(); index++)
+    for (unsigned int index = 0; index < decodings.size(); index++)
     {
         if (decodings[index].detection_box.get_confidence() != 0.0f)
         {
@@ -160,7 +160,7 @@
 
         std::vector<xt::xarray<double>> centers(boxes_num);
 
-        for (uint i=0; i < boxes_num; i++) {
+        for (unsigned int i=0; i < boxes_num; i++) {
             strided_width = network_dims[0] / strides[i];
             strided_height = network_dims[1] / strides[i];
 
@@ -203,7 +203,7 @@
     // Box distribution to distance
     auto regression_distance =  xt::reshape_view(xt::arange(0, regression_length + 1), {1, 1, regression_length + 1});
 
-    for (uint i = 0; i < raw_boxes_outputs.size(); i++)
+    for (unsigned int i = 0; i < raw_boxes_outputs.size(); i++)
     {
         // Boxes setup
         float32_t qp_scale = raw_boxes_outputs[i]->quant_info().qp_scale;
@@ -228,7 +228,7 @@
         auto keypoints_shape = {quantized_keypoints.shape(1), quantized_keypoints.shape(2)};
 
         // Bbox decoding
-        for (uint j = 0; j < uint(num_proposals); j++) {
+        for (unsigned int j = 0; j < unsigned int(num_proposals); j++) {
             confidence =    xt::row(scores, instance_index)(0);
             instance_index++;
             if (confidence < SCORE_THRESHOLD)
@@ -294,7 +294,7 @@
     
     // Prepare the scores xarray at the size we will fill in in-place
     int total_scores = 0;
-    for (uint i = 0; i < tensors.size(); i = i + 3) { 
+    for (unsigned int i = 0; i < tensors.size(); i = i + 3) { 
         total_scores += tensors[i+1]->width() * tensors[i+1]->height(); 
     }
 
@@ -304,7 +304,7 @@
 
     int view_index_scores = 0;
 
-    for (uint i = 0; i < tensors.size(); i = i + 3)
+    for (unsigned int i = 0; i < tensors.size(); i = i + 3)
     {
         // Bounding boxes extraction will be done later on only on the boxes that surpass the score threshold
         outputs_boxes[i / 3] = tensors[i];
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/common/hailomat.hpp tappas-5.1.0.mod/core/hailo/plugins/common/hailomat.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/common/hailomat.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/common/hailomat.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -72,19 +72,19 @@
 class HailoMat
 {
 protected:
-    uint m_height;
-    uint m_width;
-    uint m_native_height;
-    uint m_native_width;
-    uint m_stride;
+    unsigned int m_height;
+    unsigned int m_width;
+    unsigned int m_native_height;
+    unsigned int m_native_width;
+    unsigned int m_stride;
     int m_line_thickness;
     int m_font_thickness;
     std::vector<cv::Mat> m_matrices;
-    cv::Rect get_bounding_rect(HailoBBox bbox, uint channel_width, uint channel_height)
+    cv::Rect get_bounding_rect(HailoBBox bbox, unsigned int channel_width, unsigned int channel_height)
     {
         cv::Rect rect;
-        uint width = channel_width;
-        uint height = channel_height;
+        unsigned int width = channel_width;
+        unsigned int height = channel_height;
         rect.x = CLAMP(bbox.xmin() * width, 0, width);
         rect.y = CLAMP(bbox.ymin() * height, 0, height);
         rect.width = CLAMP(bbox.width() * width, 0, width - rect.x);
@@ -93,7 +93,7 @@
     }
 
 public:
-    HailoMat(uint height, uint width, uint stride, int line_thickness = 1, int font_thickness = 1) : m_height(height),
+    HailoMat(unsigned int height, unsigned int width, unsigned int stride, int line_thickness = 1, int font_thickness = 1) : m_height(height),
                                                                                                      m_width(width),
                                                                                                      m_native_height(height),
                                                                                                      m_native_width(width),
@@ -102,10 +102,10 @@
                                                                                                      m_font_thickness(font_thickness){};
     HailoMat() : m_height(0), m_width(0), m_native_height(0), m_native_width(0), m_stride(0), m_line_thickness(0), m_font_thickness(0){};
     virtual ~HailoMat() = default;
-    uint width() { return m_width; };
-    uint height() { return m_height; };
-    uint native_width() { return m_native_width; };
-    uint native_height() { return m_native_height; };
+    unsigned int width() { return m_width; };
+    unsigned int height() { return m_height; };
+    unsigned int native_width() { return m_native_width; };
+    unsigned int native_height() { return m_native_height; };
     std::vector<cv::Mat> &get_matrices() { return m_matrices; }
     virtual void draw_rectangle(cv::Rect rect, const cv::Scalar color) = 0;
     virtual void draw_text(std::string text, cv::Point position, double font_scale, const cv::Scalar color) = 0;
@@ -153,7 +153,7 @@
     std::string m_name;
 
 public:
-    HailoRGBMat(uint8_t *buffer, uint height, uint width, uint stride, int line_thickness = 1, int font_thickness = 1, std::string name = "HailoRGBMat") : HailoMat(height, width, stride, line_thickness, font_thickness)
+    HailoRGBMat(uint8_t *buffer, unsigned int height, unsigned int width, unsigned int stride, int line_thickness = 1, int font_thickness = 1, std::string name = "HailoRGBMat") : HailoMat(height, width, stride, line_thickness, font_thickness)
     {
         m_name = name;
         cv::Mat mat = cv::Mat(m_height, m_width, CV_8UC3, buffer, m_stride);
@@ -221,7 +221,7 @@
     }
 
 public:
-    HailoRGBAMat(uint8_t *buffer, uint height, uint width, uint stride, int line_thickness = 1, int font_thickness = 1) : HailoMat(height, width, stride, line_thickness, font_thickness)
+    HailoRGBAMat(uint8_t *buffer, unsigned int height, unsigned int width, unsigned int stride, int line_thickness = 1, int font_thickness = 1) : HailoMat(height, width, stride, line_thickness, font_thickness)
     {
         cv::Mat mat = cv::Mat(m_height, m_width, CV_8UC4, buffer, m_stride);
         m_matrices.push_back(mat);
@@ -262,17 +262,17 @@
 protected:
     cv::Scalar get_yuy2_color(cv::Scalar rgb_color)
     {
-        uint r = rgb_color[0];
-        uint g = rgb_color[1];
-        uint b = rgb_color[2];
-        uint y = RGB2Y(r, g, b);
-        uint u = RGB2U(r, g, b);
-        uint v = RGB2V(r, g, b);
+        unsigned int r = rgb_color[0];
+        unsigned int g = rgb_color[1];
+        unsigned int b = rgb_color[2];
+        unsigned int y = RGB2Y(r, g, b);
+        unsigned int u = RGB2U(r, g, b);
+        unsigned int v = RGB2V(r, g, b);
         return cv::Scalar(y, u, y, v);
     }
 
 public:
-    HailoYUY2Mat(uint8_t *buffer, uint height, uint width, uint stride, int line_thickness = 1, int font_thickness = 1) : HailoMat(height, width, stride, line_thickness, font_thickness)
+    HailoYUY2Mat(uint8_t *buffer, unsigned int height, unsigned int width, unsigned int stride, int line_thickness = 1, int font_thickness = 1) : HailoMat(height, width, stride, line_thickness, font_thickness)
     {
         m_width = m_width / 2;
         cv::Mat mat = cv::Mat(m_height, m_width, CV_8UC4, buffer, m_stride);
@@ -323,21 +323,21 @@
         +-----+-----+-----+-----+-----+-----+
     */
 protected:
-    uint m_y_stride;
-    uint m_uv_stride;
+    unsigned int m_y_stride;
+    unsigned int m_uv_stride;
     cv::Scalar get_nv12_color(cv::Scalar rgb_color)
     {
-        uint r = rgb_color[0];
-        uint g = rgb_color[1];
-        uint b = rgb_color[2];
-        uint y = RGB2Y(r, g, b);
-        uint u = RGB2U(r, g, b);
-        uint v = RGB2V(r, g, b);
+        unsigned int r = rgb_color[0];
+        unsigned int g = rgb_color[1];
+        unsigned int b = rgb_color[2];
+        unsigned int y = RGB2Y(r, g, b);
+        unsigned int u = RGB2U(r, g, b);
+        unsigned int v = RGB2V(r, g, b);
         return cv::Scalar(y, u, v);
     }
 
 public:
-    HailoNV12Mat(uint8_t *buffer, uint height, uint width, uint y_plane_stride, uint uv_plane_stride, int line_thickness = 1, int font_thickness = 1, void *plane0 = nullptr, void *plane1 = nullptr) : HailoMat(height, width, y_plane_stride, line_thickness, font_thickness)
+    HailoNV12Mat(uint8_t *buffer, unsigned int height, unsigned int width, unsigned int y_plane_stride, unsigned int uv_plane_stride, int line_thickness = 1, int font_thickness = 1, void *plane0 = nullptr, void *plane1 = nullptr) : HailoMat(height, width, y_plane_stride, line_thickness, font_thickness)
     {
         m_height = (m_height * 3 / 2);
         m_y_stride = y_plane_stride;
@@ -361,7 +361,7 @@
     virtual void draw_rectangle(cv::Rect rect, const cv::Scalar color)
     {
         cv::Scalar yuv_color = get_nv12_color(color);
-        uint thickness = m_line_thickness > 1 ? m_line_thickness / 2 : 1;
+        unsigned int thickness = m_line_thickness > 1 ? m_line_thickness / 2 : 1;
         // always floor the rect coordinates to even numbers to avoid drawing on the wrong pixel
         int y_plane_rect_x = floor_to_even_number(rect.x);
         int y_plane_rect_y = floor_to_even_number(rect.y);
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/common/image.cpp tappas-5.1.0.mod/core/hailo/plugins/common/image.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/common/image.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/common/image.cpp	2025-11-01 12:19:56.205854831 +0800
@@ -84,11 +84,11 @@
 
 void resize_nv12(std::vector<cv::Mat> &cropped_image_vec, std::vector<cv::Mat> &resized_image_vec, int interpolation)
 {
-    uint resize_width_y = resized_image_vec[0].cols;
-    uint resize_height_y = resized_image_vec[0].rows;
+    unsigned int resize_width_y = resized_image_vec[0].cols;
+    unsigned int resize_height_y = resized_image_vec[0].rows;
 
-    uint resize_width_uv = resized_image_vec[1].cols;
-    uint resize_height_uv = resized_image_vec[1].rows;
+    unsigned int resize_width_uv = resized_image_vec[1].cols;
+    unsigned int resize_height_uv = resized_image_vec[1].rows;
 
     cv::resize(cropped_image_vec[0], resized_image_vec[0], cv::Size(resize_width_y, resize_height_y), 0, 0, interpolation);
     cv::resize(cropped_image_vec[1], resized_image_vec[1], cv::Size(resize_width_uv, resize_height_uv), 0, 0, interpolation);
@@ -131,9 +131,9 @@
 HailoBBox resize_letterbox_nv12(std::vector<cv::Mat> &cropped_image_vec, std::vector<cv::Mat> &resized_image_vec, cv::Scalar color, int interpolation)
 {
     // Convert the color to YUV pixel format
-    uint y = RGB2Y(color[0], color[1], color[2]);
-    uint u = RGB2U(color[0], color[1], color[2]);
-    uint v = RGB2V(color[0], color[1], color[2]);
+    unsigned int y = RGB2Y(color[0], color[1], color[2]);
+    unsigned int u = RGB2U(color[0], color[1], color[2]);
+    unsigned int v = RGB2V(color[0], color[1], color[2]);
     cv::Scalar nv12_color(y, u, v);
 
     // Perform the letterbox resize on the Y and UV channels separately
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailoaggregator.hpp tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailoaggregator.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailoaggregator.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailoaggregator.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -45,9 +45,9 @@
     GstPad *sinkpad_sub;
     bool eos_sub;
     GstBuffer *mainframe;
-    uint num_of_frames;
-    uint expected_frames;
-    uint last_offset;
+    unsigned int num_of_frames;
+    unsigned int expected_frames;
+    unsigned int last_offset;
     gboolean flatten_detections;
 
     std::mutex mutex;
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailobasecropper.cpp tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailobasecropper.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailobasecropper.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailobasecropper.cpp	2025-11-01 12:19:56.201854833 +0800
@@ -176,7 +176,7 @@
     hailo_basecropper->drop_uncropped_buffers = false;
     hailo_basecropper->buffer_pool = NULL;
     hailo_basecropper->stream_ids_buff_offset.clear();
-    for (uint i = 0; i < GST_HAILO_CROPPER_MAX_FILTER_STREAMS; i++)
+    for (unsigned int i = 0; i < GST_HAILO_CROPPER_MAX_FILTER_STREAMS; i++)
         hailo_basecropper->filter_streams[i] = "";
 }
 
@@ -245,7 +245,7 @@
     guint len = gst_value_array_get_size(value);
     if (len > 0 && len < GST_HAILO_CROPPER_MAX_FILTER_STREAMS)
     {
-        for (uint i = 0; i < len; i++)
+        for (unsigned int i = 0; i < len; i++)
         {
             const GValue *val = gst_value_array_get_value(value, i);
             hailo_basecropper->filter_streams[i] = g_strdup(g_value_get_string(val));
@@ -273,7 +273,7 @@
         GST_ERROR("initialization of element property filter_streams: value an not empty array");
         return;
     }
-    for (uint i = 0; i < hailo_basecropper->num_streams_to_filter; i++)
+    for (unsigned int i = 0; i < hailo_basecropper->num_streams_to_filter; i++)
     {
         GValue val = G_VALUE_INIT;
         g_value_init(&val, G_TYPE_STRING);
@@ -703,7 +703,7 @@
     GstVideoFormat image_format = GST_VIDEO_INFO_FORMAT(full_image_info);
     hailo_basecropperclass->resize(hailo_basecropper, cropped_cv_mat, resized_cv_mat, crop_roi, image_format);
 
-    for (uint i = 0; i < (uint)cropped_cv_mat.size(); i++)
+    for (unsigned int i = 0; i < (unsigned int)cropped_cv_mat.size(); i++)
     {
         cropped_cv_mat[i].release();
         resized_cv_mat[i].release();
@@ -851,9 +851,9 @@
     return TRUE;
 }
 
-uint filter_streams_have_name(GstHailoBaseCropper *hailo_basecropper, const gchar *name)
+unsigned int filter_streams_have_name(GstHailoBaseCropper *hailo_basecropper, const gchar *name)
 {
-    for (uint i = 0; i < hailo_basecropper->num_streams_to_filter; ++i)
+    for (unsigned int i = 0; i < hailo_basecropper->num_streams_to_filter; ++i)
     {
         if (strcmp(name, hailo_basecropper->filter_streams[i]) == 0)
             return 1;
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailobasecropper.hpp tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailobasecropper.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/cropping/gsthailobasecropper.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/cropping/gsthailobasecropper.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -33,15 +33,15 @@
     GstElement element;
     gboolean use_internal_offset;
     gboolean drop_uncropped_buffers;
-    uint internal_offset;
-    uint cropping_period;
+    unsigned int internal_offset;
+    unsigned int cropping_period;
     #ifdef HAILO15_TARGET
     bool use_dsp;
     guint bufferpool_max_size;
     guint bufferpool_min_size;
     #endif
     GstBufferPool *buffer_pool;
-    uint num_streams_to_filter = 0;
+    unsigned int num_streams_to_filter = 0;
     GstPad *sinkpad, *srcpad_crop, *srcpad_main;
     std::map<std::string, int> stream_ids_buff_offset;
     const gchar *filter_streams[GST_HAILO_CROPPER_MAX_FILTER_STREAMS];
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/export/encode_json.hpp tappas-5.1.0.mod/core/hailo/plugins/export/encode_json.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/export/encode_json.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/export/encode_json.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -189,7 +189,7 @@
 
         rapidjson::Value data_array(rapidjson::kArrayType);
         auto data = mask->get_data();
-        for (uint i=0; i < data.size(); i++)
+        for (unsigned int i=0; i < data.size(); i++)
             data_array.PushBack(rapidjson::Value(data[i]), allocator);
         entry_object.AddMember( "data", data_array, allocator );
 
@@ -239,7 +239,7 @@
 
         rapidjson::Value data_array(rapidjson::kArrayType);
         std::vector<float> data = matrix->get_data();
-        for (uint i=0; i < data.size(); i++)
+        for (unsigned int i=0; i < data.size(); i++)
             data_array.PushBack(rapidjson::Value(data[i]), allocator);
         entry_object.AddMember( "data", data_array, allocator );
 
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/export/export_file/gsthailoexportfile.hpp tappas-5.1.0.mod/core/hailo/plugins/export/export_file/gsthailoexportfile.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/export/export_file/gsthailoexportfile.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/export/export_file/gsthailoexportfile.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -25,7 +25,7 @@
     GstBaseTransform base_hailoexportfile;
     gchar *file_path;
     FILE* json_file;
-    uint buffer_offset;
+    unsigned int buffer_offset;
 };
 
 struct _GstHailoExportFileClass
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/export/export_zmq/gsthailoexportzmq.hpp tappas-5.1.0.mod/core/hailo/plugins/export/export_zmq/gsthailoexportzmq.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/export/export_zmq/gsthailoexportzmq.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/export/export_zmq/gsthailoexportzmq.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -25,7 +25,7 @@
 {
     GstBaseTransform base_hailoexportzmq;
     gchar *address;
-    uint buffer_offset;
+    unsigned int buffer_offset;
     zmq::context_t *context;
     zmq::socket_t *socket;
 };
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/filter/gsthailofilter.cpp tappas-5.1.0.mod/core/hailo/plugins/filter/gsthailofilter.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/filter/gsthailofilter.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/filter/gsthailofilter.cpp	2025-11-01 12:19:56.217854827 +0800
@@ -3,7 +3,7 @@
  * Distributed under the LGPL license (https://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt)
  **/
 #include "gsthailofilter.hpp"
-#include "tensor_meta.hpp"
+#include "metadata/tensor_meta.hpp"
 #include "gst_hailo_meta.hpp"
 #include <gst/video/video.h>
 #include <gst/gst.h>
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/gallery/gallery.hpp tappas-5.1.0.mod/core/hailo/plugins/gallery/gallery.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/gallery/gallery.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/gallery/gallery.hpp	2025-11-01 12:19:56.201854833 +0800
@@ -56,14 +56,14 @@
     std::map<int, int> tracking_id_to_global_id;
     std::vector<std::string> m_embedding_names;
     float m_similarity_thr;
-    uint m_queue_size;
+    unsigned int m_queue_size;
     FILE *m_json_file;
     bool m_save_new_embeddings;
     char *m_json_file_path;
     bool m_load_local_embeddings;
 
 public:
-    Gallery(float similarity_thr = 0.15, uint queue_size = 100) : m_similarity_thr(similarity_thr), m_queue_size(queue_size),
+    Gallery(float similarity_thr = 0.15, unsigned int queue_size = 100) : m_similarity_thr(similarity_thr), m_queue_size(queue_size),
                                                                   m_json_file(nullptr), m_save_new_embeddings(false),
                                                                   m_json_file_path(nullptr), m_load_local_embeddings(false){};
 
@@ -129,7 +129,7 @@
         for (auto matrix : matrix_objs)
         {
             HailoMatrixPtr matrix_ptr = std::dynamic_pointer_cast<HailoMatrix>(matrix);
-            uint global_id = create_new_global_id();
+            unsigned int global_id = create_new_global_id();
             add_embedding(global_id, matrix_ptr);
         }
 
@@ -137,7 +137,7 @@
         this->m_json_file = nullptr;
     }
 
-    void add_embedding(uint global_id, HailoMatrixPtr matrix)
+    void add_embedding(unsigned int global_id, HailoMatrixPtr matrix)
     {
         global_id--;
         if (m_embeddings[global_id].size() >= m_queue_size)
@@ -175,7 +175,7 @@
         this->m_json_file = nullptr;
     }
 
-    void save_embedding_to_json_file(HailoMatrixPtr matrix, const uint global_id)
+    void save_embedding_to_json_file(HailoMatrixPtr matrix, const unsigned int global_id)
     {
         if (this->m_save_new_embeddings)
         {
@@ -184,19 +184,19 @@
         }
     }
 
-    uint create_new_global_id()
+    unsigned int create_new_global_id()
     {
         std::vector<HailoMatrixPtr> queue;
         m_embeddings.push_back(queue);
-        uint global_id = m_embeddings.size();
+        unsigned int global_id = m_embeddings.size();
         return global_id;
     }
 
-    std::pair<uint, float> get_closest_global_id(HailoMatrixPtr matrix)
+    std::pair<unsigned int, float> get_closest_global_id(HailoMatrixPtr matrix)
     {
         auto distances = get_embeddings_distances(matrix);
         auto global_id = xt::argpartition(distances, 1, xt::xnone())[0];
-        return std::pair<uint, float>(global_id + 1, distances[global_id]);
+        return std::pair<unsigned int, float>(global_id + 1, distances[global_id]);
     }
 
     HailoMatrixPtr get_embedding_matrix(HailoDetectionPtr detection)
@@ -215,7 +215,7 @@
         return std::dynamic_pointer_cast<HailoMatrix>(embeddings[0]);
     }
 
-    void handle_local_embedding(HailoDetectionPtr detection, const uint global_id)
+    void handle_local_embedding(HailoDetectionPtr detection, const unsigned int global_id)
     {
         if ((global_id - 1) < this->m_embedding_names.size())
         {
@@ -229,7 +229,7 @@
         }
     }
 
-    void update_embeddings_and_add_id_to_object(HailoMatrixPtr new_embedding, HailoDetectionPtr detection, const uint global_id, const int unique_id)
+    void update_embeddings_and_add_id_to_object(HailoMatrixPtr new_embedding, HailoDetectionPtr detection, const unsigned int global_id, const int unique_id)
     {
         // Attach global id to tracking id
         tracking_id_to_global_id[unique_id] = global_id;
@@ -264,13 +264,13 @@
         if (m_embeddings.empty())
         {
             // Gallery is empty, adding new global id
-            uint global_id = create_new_global_id();
+            unsigned int global_id = create_new_global_id();
             save_embedding_to_json_file(new_embedding, global_id);
             update_embeddings_and_add_id_to_object(new_embedding, detection, global_id, track_id);
             return;
         }
 
-        uint closest_global_id;
+        unsigned int closest_global_id;
         float min_distance;
         // Get closest global id by distance between embeddings
         std::tie(closest_global_id, min_distance) = get_closest_global_id(new_embedding);
@@ -279,7 +279,7 @@
             // if smallest distance is bigger than threshold and local gallery is not loaded -> create new global ID
             if (!this->m_load_local_embeddings)
             {
-                uint global_id = create_new_global_id();
+                unsigned int global_id = create_new_global_id();
                 save_embedding_to_json_file(new_embedding, global_id);
                 update_embeddings_and_add_id_to_object(new_embedding, detection, global_id, track_id);
             }
@@ -305,7 +305,7 @@
         }
     };
     void set_similarity_threshold(float thr) { this->m_similarity_thr = thr; };
-    void set_queue_size(uint size) { m_queue_size = size; };
+    void set_queue_size(unsigned int size) { m_queue_size = size; };
     float get_similarity_threshold() { return m_similarity_thr; };
-    uint get_queue_size() { return m_queue_size; };
+    unsigned int get_queue_size() { return m_queue_size; };
 };
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/gray_scale/gsthailograytonv12.cpp tappas-5.1.0.mod/core/hailo/plugins/gray_scale/gsthailograytonv12.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/gray_scale/gsthailograytonv12.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/gray_scale/gsthailograytonv12.cpp	2025-11-01 12:19:56.217854827 +0800
@@ -3,7 +3,7 @@
  * Distributed under the LGPL license (https://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt)
  **/
 #include "gsthailograytonv12.hpp"
-#include "tensor_meta.hpp"
+#include "metadata/tensor_meta.hpp"
 #include "gst_hailo_meta.hpp"
 #include <gst/video/video.h>
 #include <gst/gst.h>
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/gray_scale/gsthailonv12togray.cpp tappas-5.1.0.mod/core/hailo/plugins/gray_scale/gsthailonv12togray.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/gray_scale/gsthailonv12togray.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/gray_scale/gsthailonv12togray.cpp	2025-11-01 12:19:56.217854827 +0800
@@ -3,7 +3,7 @@
  * Distributed under the LGPL license (https://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt)
  **/
 #include "gsthailonv12togray.hpp"
-#include "tensor_meta.hpp"
+#include "metadata/tensor_meta.hpp"
 #include "gst_hailo_meta.hpp"
 #include <gst/video/video.h>
 #include <gst/gst.h>
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailomuxer.hpp tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailomuxer.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailomuxer.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailomuxer.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -48,10 +48,10 @@
     GstBuffer *mainframe;
     std::queue<GstBuffer *> sub_buffers_queue;
     gboolean leaky_sub;
-    uint last_offset;
+    unsigned int last_offset;
     gboolean sync_counters;
-    uint current_counter_main;
-    uint current_counter_sub;
+    unsigned int current_counter_main;
+    unsigned int current_counter_sub;
 
     std::mutex mutex;
     std::condition_variable cv_main;
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailoroundrobin.cpp tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailoroundrobin.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailoroundrobin.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailoroundrobin.cpp	2025-11-01 12:19:56.205854831 +0800
@@ -271,11 +271,11 @@
     while (!hailo_round_robin->stop_thread)
     {
         // iterate the pad queues and push the first buffer in each queueq
-        for (uint i = 0; i < hailo_round_robin->pad_queues.size(); i++)
+        for (unsigned int i = 0; i < hailo_round_robin->pad_queues.size(); i++)
         {
             if (hailo_round_robin->pad_queues[i] != NULL)
             {
-                for (uint j = 0; j <= hailo_round_robin->retries_num; j++)
+                for (unsigned int j = 0; j <= hailo_round_robin->retries_num; j++)
                 {
                     if (hailo_round_robin->pad_queues[i]->empty())
                     {
@@ -837,12 +837,12 @@
         if (hailo_round_robin->mode != GST_HAILO_ROUND_ROBIN_MODE_FUNNEL_MODE)
         {
             hailo_round_robin->stop_thread = true;
-            for (uint i = 0; i < hailo_round_robin->condition_vars_blocking.size(); i++)
+            for (unsigned int i = 0; i < hailo_round_robin->condition_vars_blocking.size(); i++)
             {
                 if (hailo_round_robin->condition_vars_blocking[i] != NULL)
                     hailo_round_robin->condition_vars_blocking[i]->notify_all();
             }
-            for (uint i = 0; i < hailo_round_robin->condition_vars_non_blocking.size(); i++)
+            for (unsigned int i = 0; i < hailo_round_robin->condition_vars_non_blocking.size(); i++)
             {
                 if (hailo_round_robin->condition_vars_non_blocking[i] != NULL)
                     hailo_round_robin->condition_vars_non_blocking[i]->notify_all();
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailoroundrobin.hpp tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailoroundrobin.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/muxer/gsthailoroundrobin.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/muxer/gsthailoroundrobin.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -55,12 +55,12 @@
     GstPad *srcpad;
     size_t current_pad_num;
     GstHailoRoundRobinMode mode;
-    uint num_of_sink_pads;
+    unsigned int num_of_sink_pads;
     std::unique_ptr<std::shared_mutex> num_of_pads_mutex;
-    uint retries_num;
-    uint queue_size;
-    uint wait_time;
-    uint preroll_frames;
+    unsigned int retries_num;
+    unsigned int queue_size;
+    unsigned int wait_time;
+    unsigned int preroll_frames;
     std::vector<std::unique_ptr<std::mutex>> mutexes_blocking;
     std::vector<std::unique_ptr<std::mutex>> mutexes_non_blocking;
     std::unique_ptr<std::shared_mutex> counter_mutex;
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/overlay/gsthailooverlay.cpp tappas-5.1.0.mod/core/hailo/plugins/overlay/gsthailooverlay.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/overlay/gsthailooverlay.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/overlay/gsthailooverlay.cpp	2025-11-01 12:19:56.205854831 +0800
@@ -87,7 +87,7 @@
     g_object_class_install_property(gobject_class, PROP_SHOW_CONF,
                                     g_param_spec_boolean("show-confidence", "show-confidence", "Whether to display confidence on detections, classifications etc...", true,
                                                          (GParamFlags)(GST_PARAM_CONTROLLABLE | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
-    // install property mask-overlay-n-threads uint default value 0
+    // install property mask-overlay-n-threads unsigned int default value 0
     g_object_class_install_property(gobject_class, PROP_MASK_OVERLAY_N_THREADS,
                                     g_param_spec_uint("mask-overlay-n-threads", "mask-overlay-n-threads", "Number of threads to use for parallel mask drawing. Default 0 (Will use the default value OpenCV initializes - effected by the system capabilities).", 0, G_MAXUINT, 0,
                                                       (GParamFlags)(GST_PARAM_MUTABLE_READY | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/overlay/overlay.cpp tappas-5.1.0.mod/core/hailo/plugins/overlay/overlay.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/overlay/overlay.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/overlay/overlay.cpp	2025-11-01 12:19:56.221854826 +0800
@@ -17,6 +17,7 @@
 #include <algorithm>
 #include "overlay.hpp"
 #include "overlay_utils.hpp"
+#include <iostream>
 #include "hailo_common.hpp"
 
 #define SPACE " "
@@ -72,7 +73,7 @@
     return std::to_string(confidence_percentage) + "%";
 }
 
-static overlay_status_t draw_classification(HailoMat &mat, HailoROIPtr roi, std::string text, uint number_of_classifications, size_t color_id = NULL_COLOR_ID)
+static overlay_status_t draw_classification(HailoMat &mat, HailoROIPtr roi, std::string text, unsigned int number_of_classifications, size_t color_id = NULL_COLOR_ID)
 {
     auto bbox = hailo_common::create_flattened_bbox(roi->get_bbox(), roi->get_scaling_bbox());
     int roi_xmin = bbox.xmin() * mat.native_width();
@@ -113,11 +114,11 @@
     {
         if ((points.at(pair.first).confidence() > 0) && (points.at(pair.second).confidence() > 0))
         {
-            uint x1 = ((points.at(pair.first).x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
-            uint y1 = ((points.at(pair.first).y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
+            unsigned int x1 = ((points.at(pair.first).x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
+            unsigned int y1 = ((points.at(pair.first).y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
 
-            uint x2 = ((points.at(pair.second).x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
-            uint y2 = ((points.at(pair.second).y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
+            unsigned int x2 = ((points.at(pair.second).x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
+            unsigned int y2 = ((points.at(pair.second).y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
 
             cv::Point joint1 = cv::Point(x1, y1);
             cv::Point joint2 = cv::Point(x2, y2);
@@ -130,8 +131,8 @@
     {
         if (point.confidence() >= landmarks->get_threshold())
         {
-            uint x = ((point.x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
-            uint y = ((point.y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
+            unsigned int x = ((point.x() * bbox.width()) + bbox.xmin()) * hmat.native_width();
+            unsigned int y = ((point.y() * bbox.height()) + bbox.ymin()) * hmat.native_height();
             // Draw the keypoint (multiply x,y values by the sizes of the frame)
             auto center = cv::Point(x, y);
             hmat.draw_ellipse(center, {R, R}, 0, 0, 360, get_color(7), landmark_point_radius);
@@ -177,7 +178,7 @@
     auto bbox_max = cv::Point(bbox.xmax() * mat.width(), bbox.ymax() * mat.height());
     cv::Rect rect(bbox_min, bbox_max);
     cv::Scalar color;
-    uint tile_layer = tile->get_layer();
+    unsigned int tile_layer = tile->get_layer();
     if (tile_layer < tile_layer_color_table.size())
         color = tile_layer_color_table[tile_layer];
     else
@@ -252,7 +253,7 @@
  * @param roi region of interest
  * @return overlay_status_t
  */
-static overlay_status_t draw_depth_mask(cv::Mat &image_planes, HailoDepthMaskPtr mask, HailoROIPtr roi, const uint mask_overlay_n_threads)
+static overlay_status_t draw_depth_mask(cv::Mat &image_planes, HailoDepthMaskPtr mask, HailoROIPtr roi, const unsigned int mask_overlay_n_threads)
 {
     cv::Mat resized_mask_data;
     cv::Mat destinationROI;
@@ -294,7 +295,7 @@
  * @return overlay_status_t OVERLAY_STATUS_OK
  */
 static overlay_status_t
-draw_class_mask(cv::Mat &image_planes, HailoClassMaskPtr mask, HailoROIPtr roi, const uint mask_overlay_n_threads)
+draw_class_mask(cv::Mat &image_planes, HailoClassMaskPtr mask, HailoROIPtr roi, const unsigned int mask_overlay_n_threads)
 {
     cv::Mat resized_mask_data;
     cv::Mat destinationROI;
@@ -318,7 +319,7 @@
  * @param roi the region of interest
  * @return overlay_status_t OVERLAY_STATUS_OK
  */
-static overlay_status_t draw_conf_class_mask(cv::Mat &image_planes, HailoConfClassMaskPtr mask, HailoROIPtr roi, const uint mask_overlay_n_threads)
+static overlay_status_t draw_conf_class_mask(cv::Mat &image_planes, HailoConfClassMaskPtr mask, HailoROIPtr roi, const unsigned int mask_overlay_n_threads)
 {
     cv::Mat resized_mask_data;
     cv::Mat destinationROI;
@@ -335,10 +336,10 @@
     return OVERLAY_STATUS_OK;
 }
 
-overlay_status_t draw_all(HailoMat &hmat, HailoROIPtr roi, float landmark_point_radius, bool show_confidence, bool local_gallery, const uint mask_overlay_n_threads)
+overlay_status_t draw_all(HailoMat &hmat, HailoROIPtr roi, float landmark_point_radius, bool show_confidence, bool local_gallery, const unsigned int mask_overlay_n_threads)
 {
     overlay_status_t ret = OVERLAY_STATUS_UNINITIALIZED;
-    uint number_of_classifications = 0;
+    unsigned int number_of_classifications = 0;
     cv::Mat &mat = hmat.get_matrices()[0];
     for (auto obj : roi->get_objects())
     {
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/overlay/overlay.hpp tappas-5.1.0.mod/core/hailo/plugins/overlay/overlay.hpp
--- tappas-5.1.0.orig/core/hailo/plugins/overlay/overlay.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/overlay/overlay.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -27,7 +27,7 @@
 } overlay_status_t;
 
 __BEGIN_DECLS
-overlay_status_t draw_all(HailoMat &hmat, HailoROIPtr roi, float landmark_point_radius, bool show_confidence = true, bool local_gallery = false, uint mask_overlay_n_threads = 0);
+overlay_status_t draw_all(HailoMat &hmat, HailoROIPtr roi, float landmark_point_radius, bool show_confidence = true, bool local_gallery = false, unsigned int mask_overlay_n_threads = 0);
 void face_blur(HailoMat &mat, HailoROIPtr roi);
 
 cv::Scalar indexToColor(size_t index);
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/python/gsthailopython.cpp tappas-5.1.0.mod/core/hailo/plugins/python/gsthailopython.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/python/gsthailopython.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/python/gsthailopython.cpp	2025-11-01 12:19:56.221854826 +0800
@@ -8,7 +8,7 @@
 
 #include "gsthailopython.hpp"
 #include "gst_hailo_meta.hpp"
-#include "tensor_meta.hpp"
+#include "metadata/tensor_meta.hpp"
 #include "hailopython_infra.hpp"
 #include <gst/gst.h>
 #include <gst/video/gstvideofilter.h>
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/python/hailo_python_api.cpp tappas-5.1.0.mod/core/hailo/plugins/python/hailo_python_api.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/python/hailo_python_api.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/python/hailo_python_api.cpp	2025-11-01 12:19:56.205854831 +0800
@@ -252,7 +252,7 @@
     return HailoTensor(static_cast<uint8_t *>(data.request().ptr), tensor_meta_info);
 }
 
-HailoTensor tensor_init_full(pybind11::object data, std::string name, uint height, uint width, uint features, float qp_zp, float qp_scale, int type)
+HailoTensor tensor_init_full(pybind11::object data, std::string name, unsigned int height, unsigned int width, unsigned int features, float qp_zp, float qp_scale, int type)
 {
 
     hailo_tensor_metadata_t info;
@@ -404,7 +404,7 @@
             .def("add_tensor", &HailoMainObject::add_tensor, "Add tensor", "tensor"_a)
             .def("remove_object", py::overload_cast<HailoObjectPtr>(&HailoMainObject::remove_object),
                  "Remove object", "obj"_a)
-            .def("remove_object", py::overload_cast<uint>(&HailoMainObject::remove_object),
+            .def("remove_object", py::overload_cast<unsigned int>(&HailoMainObject::remove_object),
                  "Remove object", "index"_a)
             .def("get_tensor", &HailoMainObject::get_tensor, "Get tensor", "name"_a)
             .def("has_tensors", &HailoMainObject::has_tensors, "Has tensors")
@@ -449,7 +449,7 @@
     {
         py::class_<HailoTileROI, HailoROI, __HailoTileROIGlue, std::shared_ptr<HailoTileROI>>(
             m, "HailoTileROI")
-            .def(py::init<HailoBBox, uint, float, float, uint, hailo_tiling_mode_t>(), py::arg("bbox"), py::arg("index"), py::arg("overlap_x_axis"), py::arg("overlap_y_axis"), py::arg("layer"), py::arg("mode"))
+            .def(py::init<HailoBBox, unsigned int, float, float, unsigned int, hailo_tiling_mode_t>(), py::arg("bbox"), py::arg("index"), py::arg("overlap_x_axis"), py::arg("overlap_y_axis"), py::arg("layer"), py::arg("mode"))
             .def("get_type", &HailoTileROI::get_type, "Get type")
             .def("overlap_x_axis", &HailoTileROI::get_overlap_x_axis, "Overlap X axis")
             .def("overlap_y_axis", &HailoTileROI::get_overlap_y_axis, "Overlap Y axis")
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/tiling/gsthailotileaggregator.cpp tappas-5.1.0.mod/core/hailo/plugins/tiling/gsthailotileaggregator.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/tiling/gsthailotileaggregator.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/tiling/gsthailotileaggregator.cpp	2025-11-01 12:19:56.201854833 +0800
@@ -270,9 +270,9 @@
               [](HailoDetectionPtr a, HailoDetectionPtr b)
               { return a->get_confidence() > b->get_confidence(); });
 
-    for (uint index = 0; index < objects.size(); index++)
+    for (unsigned int index = 0; index < objects.size(); index++)
     {
-        for (uint jindex = index + 1; jindex < objects.size(); jindex++)
+        for (unsigned int jindex = index + 1; jindex < objects.size(); jindex++)
         {
             if (objects[index]->get_class_id() == objects[jindex]->get_class_id())
             {
diff -Naur tappas-5.1.0.orig/core/hailo/plugins/tiling/gsthailotilecropper.cpp tappas-5.1.0.mod/core/hailo/plugins/tiling/gsthailotilecropper.cpp
--- tappas-5.1.0.orig/core/hailo/plugins/tiling/gsthailotilecropper.cpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/plugins/tiling/gsthailotilecropper.cpp	2025-11-01 12:19:56.201854833 +0800
@@ -19,7 +19,7 @@
 #define DEFAULT_OVERLAP_X_AXIS 0
 #define DEFAULT_OVERLAP_Y_AXIS 0
 #define DEFAULT_MULTI_SCALE_LEVEL 2
-static const uint scales_template[][2]{{1, 1}, {2, 2}, {3, 3}};
+static const unsigned int scales_template[][2]{{1, 1}, {2, 2}, {3, 3}};
 
 enum
 {
@@ -213,7 +213,7 @@
  * Create one HailoTileROI includes the bbox that represents a tile.
  * add the requested overlap, scale it to the width, height of the frame
  *
- * @param[in] index   uint,     index of the tile.
+ * @param[in] index   unsigned int,     index of the tile.
  * @param[in] col_overlap   float,     x axis overlap between tiles (columns).
  * @param[in] row_overlap   float,     y axis overlap between tiles (rows).
  * @param[in] xmin   float,   min X of tile tile.
@@ -222,7 +222,7 @@
  * @param[in] ymax   float,   max Y of tile tile.
  * @return HailoTileROI, prepared Tile ROI object.
  */
-static HailoTileROI create_tile_roi(const uint &index, const float &col_overlap, const float &row_overlap, const float &xmin, const float &ymin, const float &xmax, const float &ymax, const uint &layer, hailo_tiling_mode_t tiling_mode)
+static HailoTileROI create_tile_roi(const unsigned int &index, const float &col_overlap, const float &row_overlap, const float &xmin, const float &ymin, const float &xmax, const float &ymax, const unsigned int &layer, hailo_tiling_mode_t tiling_mode)
 {
     float x = CLAMP(xmin - col_overlap, 0, 1);
     float y = CLAMP(ymin - row_overlap, 0, 1);
@@ -232,7 +232,7 @@
     return HailoTileROI(HailoBBox(x, y, width, height), index, col_overlap, row_overlap, layer, tiling_mode);
 }
 
-static void prepare_tiles(HailoROIPtr hailo_roi, std::vector<HailoROIPtr> &crop_rois, float tiles_along_x_axis, float tiles_along_y_axis, float overlap_x_axis, float overlap_y_axis, uint layer, hailo_tiling_mode_t tiling_mode)
+static void prepare_tiles(HailoROIPtr hailo_roi, std::vector<HailoROIPtr> &crop_rois, float tiles_along_x_axis, float tiles_along_y_axis, float overlap_x_axis, float overlap_y_axis, unsigned int layer, hailo_tiling_mode_t tiling_mode)
 {
     // Calculate the scale for a tile for col and row
     double row_step = 1 / double(tiles_along_y_axis);
@@ -244,7 +244,7 @@
     float row_overlap = overlap_y_axis * row_step;
 
     double col_offset = 0;
-    uint index = 0;
+    unsigned int index = 0;
     while (float(row_offset + row_step) <= 1)
     {
         while (float(col_offset + col_step) <= 1)
@@ -283,13 +283,13 @@
     HailoROIPtr hailo_roi = get_hailo_main_roi(buf, true);
 
     // Calculate the total number of tiles
-    uint total_num_of_tiles = hailotilecropper->tiles_along_x_axis * hailotilecropper->tiles_along_x_axis;
-    uint num_of_scales = hailotilecropper->multi_scale_level;
+    unsigned int total_num_of_tiles = hailotilecropper->tiles_along_x_axis * hailotilecropper->tiles_along_x_axis;
+    unsigned int num_of_scales = hailotilecropper->multi_scale_level;
 
     if (hailotilecropper->tiling_mode == MULTI_SCALE)
     {
         // In multi-scale mode - calculate the proper number of tiles referring to scales
-        for (uint i = 0; i < num_of_scales; i++)
+        for (unsigned int i = 0; i < num_of_scales; i++)
             total_num_of_tiles += (scales_template[i][0] * scales_template[i][1]);
     }
 
@@ -302,7 +302,7 @@
 
     // Prepare tiles for every scale requsted as multi scale
     if (hailotilecropper->tiling_mode == MULTI_SCALE)
-        for (uint i = 0; i < num_of_scales; i++)
+        for (unsigned int i = 0; i < num_of_scales; i++)
             prepare_tiles(hailo_roi, crop_rois, scales_template[i][0], scales_template[i][1], hailotilecropper->overlap_x_axis, hailotilecropper->overlap_y_axis, (i + 1), (hailo_tiling_mode_t)hailotilecropper->tiling_mode);
 
     return crop_rois;
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_converters.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_converters.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_converters.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_converters.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -31,7 +31,7 @@
 inline std::vector<STrack> JDETracker::hailo_detections_to_stracks(std::vector<HailoDetectionPtr> &inputs, int frame_id, std::vector<hailo_object_t> hailo_objects_blacklist)
 {
     std::vector<STrack> detections(inputs.size());
-    for (uint i = 0; i < inputs.size(); i++)
+    for (unsigned int i = 0; i < inputs.size(); i++)
     {
         HailoBBox bbox = inputs[i]->get_bbox();
         std::vector<float> detection_box = {bbox.xmin(), bbox.ymin(), bbox.width(), bbox.height()};
@@ -56,7 +56,7 @@
 {
     std::vector<HailoDetectionPtr> objects;
     objects.reserve(stracks.size());
-    for (uint i = 0; i < stracks.size(); i++)
+    for (unsigned int i = 0; i < stracks.size(); i++)
     {
         HailoDetectionPtr detection_ptr = stracks[i].get_hailo_detection();
         if (nullptr != detection_ptr)
@@ -97,7 +97,7 @@
 
 inline STrack *JDETracker::get_detection_with_id(int target_track_id)
 {
-    for (uint i = 0; i < m_tracked_stracks.size(); i++)
+    for (unsigned int i = 0; i < m_tracked_stracks.size(); i++)
     {
         if (target_track_id == m_tracked_stracks[i].m_track_id)
         {
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_embedding.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_embedding.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_embedding.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_embedding.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -46,15 +46,15 @@
         return;
     }
 
-    for (uint i = 0; i < tracks.size(); i++)
+    for (unsigned int i = 0; i < tracks.size(); i++)
     {
         std::vector<float> cost_matrix_tmp(detections.size());
         std::vector<float> track_feature = tracks[i]->m_smooth_feat;
-        for (uint j = 0; j < detections.size(); j++)
+        for (unsigned int j = 0; j < detections.size(); j++)
         {
             std::vector<float> det_feature = detections[j].m_curr_feat;
             float feat_square = 0.0;
-            for (uint k = 0; k < det_feature.size(); k++)
+            for (unsigned int k = 0; k < det_feature.size(); k++)
             {
                 feat_square += (track_feature[k] - det_feature[k])*(track_feature[k] - det_feature[k]);
             }
@@ -93,19 +93,19 @@
     float gating_threshold = this->m_kalman_filter.chi2inv95[gating_dim];
 
     std::vector<TrackerTypes::DETECTBOX> measurements(detections.size());
-    for (uint i = 0; i < detections.size(); i++)
+    for (unsigned int i = 0; i < detections.size(); i++)
     {
         std::vector<float> tlwh_ = detections[i].to_xyah();
         TrackerTypes::DETECTBOX measurement = {{tlwh_[0], tlwh_[1], tlwh_[2], tlwh_[3]}};
         measurements[i] = measurement;
     }
 
-    for (uint i = 0; i < tracks.size(); i++)
+    for (unsigned int i = 0; i < tracks.size(); i++)
     {
         xt::xarray<float, xt::layout_type::row_major> gating_distance = m_kalman_filter.gating_distance(tracks[i]->m_mean,
                                                                                                         tracks[i]->m_covariance,
                                                                                                         measurements);
-        for (uint j = 0; j < cost_matrix[i].size(); j++)
+        for (unsigned int j = 0; j < cost_matrix[i].size(); j++)
         {
             if (gating_distance[j] > gating_threshold)
             {
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_ious.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_ious.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_ious.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_ious.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -41,10 +41,10 @@
         return ious;
 
     //Calculate the ious between each possible pair of boxes from set A and set B
-    for (uint k = 0; k < btlbrs.size(); k++)
+    for (unsigned int k = 0; k < btlbrs.size(); k++)
     {
         float box_area = (btlbrs[k][2] - btlbrs[k][0]) * (btlbrs[k][3] - btlbrs[k][1]);
-        for (uint n = 0; n < atlbrs.size(); n++)
+        for (unsigned int n = 0; n < atlbrs.size(); n++)
         {
             float iw = std::min(atlbrs[n][2], btlbrs[k][2]) - std::max(atlbrs[n][0], btlbrs[k][0]);
             if (iw > 0.0f)
@@ -101,11 +101,11 @@
     // Prepare a set of bounding boxes from each of the two sets of STracks
     std::vector<std::vector<float>> atlbrs( atracks.size() , std::vector<float> (4));
     std::vector<std::vector<float>> btlbrs( btracks.size() , std::vector<float> (4));
-    for (uint i = 0; i < atracks.size(); i++)
+    for (unsigned int i = 0; i < atracks.size(); i++)
     {
         atlbrs[i] = atracks[i]->tlbr();
     }
-    for (uint i = 0; i < btracks.size(); i++)
+    for (unsigned int i = 0; i < btracks.size(); i++)
     {
         btlbrs[i] = btracks[i].tlbr();
     }
@@ -116,9 +116,9 @@
     // The cost matrix will have the same shape as the ious graph
     std::vector<std::vector<float>> cost_matrix( atracks.size() , std::vector<float> (btracks.size()));
     //The cost matrix = 1 - ious
-    for (uint i = 0; i < _ious.size(); i++)
+    for (unsigned int i = 0; i < _ious.size(); i++)
     {
-        for (uint j = 0; j < _ious[i].size(); j++)
+        for (unsigned int j = 0; j < _ious[i].size(); j++)
         {
             cost_matrix[i][j] = 1 - _ious[i][j];
         }
@@ -152,11 +152,11 @@
     // Prepare a set of bounding boxes from each of the two sets of STracks
     std::vector<std::vector<float>> atlbrs( atracks.size() , std::vector<float> (4));
     std::vector<std::vector<float>> btlbrs( btracks.size() , std::vector<float> (4));
-    for (uint i = 0; i < atracks.size(); i++)
+    for (unsigned int i = 0; i < atracks.size(); i++)
     {
         atlbrs[i] = atracks[i].tlbr();
     }
-    for (uint i = 0; i < btracks.size(); i++)
+    for (unsigned int i = 0; i < btracks.size(); i++)
     {
         btlbrs[i] = btracks[i].tlbr();
     }
@@ -166,9 +166,9 @@
     // The cost matrix will have the same shape as the ious graph
     std::vector<std::vector<float>> cost_matrix( atracks.size() , std::vector<float> (btracks.size()));
     //The cost matrix = 1 - ious
-    for (uint i = 0; i < _ious.size(); i++)
+    for (unsigned int i = 0; i < _ious.size(); i++)
     {
-        for (uint j = 0; j < _ious[i].size(); j++)
+        for (unsigned int j = 0; j < _ious[i].size(); j++)
         {
             cost_matrix[i][j] = 1 - _ious[i][j];
         }
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_lapjv.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_lapjv.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_lapjv.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_lapjv.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -63,21 +63,21 @@
 
     n = n_rows + n_cols;
     cost_c_extended.resize(n);
-    for (uint i = 0; i < cost_c_extended.size(); i++) {
+    for (unsigned int i = 0; i < cost_c_extended.size(); i++) {
         cost_c_extended[i].resize(n);
     }
 
-    for (uint i = 0; i < cost_c_extended.size(); i++)
+    for (unsigned int i = 0; i < cost_c_extended.size(); i++)
     {
-        for (uint j = 0; j < cost_c_extended[i].size(); j++)
+        for (unsigned int j = 0; j < cost_c_extended[i].size(); j++)
         {
             cost_c_extended[i][j] = cost_limit / 2.0;
         }
     }
 
-    for (uint i = n_rows; i < cost_c_extended.size(); i++)
+    for (unsigned int i = n_rows; i < cost_c_extended.size(); i++)
     {
-        for (uint j = n_cols; j < cost_c_extended[i].size(); j++)
+        for (unsigned int j = n_cols; j < cost_c_extended[i].size(); j++)
         {
             cost_c_extended[i][j] = 0;
         }
@@ -137,7 +137,7 @@
 
         if (return_cost)
         {
-            for (uint i = 0; i < rowsol.size(); i++)
+            for (unsigned int i = 0; i < rowsol.size(); i++)
             {
                 if (rowsol[i] != -1)
                 {
@@ -148,7 +148,7 @@
     }
     else if (return_cost)
     {
-        for (uint i = 0; i < rowsol.size(); i++)
+        for (unsigned int i = 0; i < rowsol.size(); i++)
         {
             opt += cost_ptr[i][rowsol[i]];
         }
@@ -214,7 +214,7 @@
     std::vector<int> colsol;
     lapjv_external(cost_matrix, rowsol, colsol, thresh);
 
-    for (uint i = 0; i < rowsol.size(); i++)
+    for (unsigned int i = 0; i < rowsol.size(); i++)
     {
         if (rowsol[i] >= 0)
         {
@@ -226,7 +226,7 @@
         }
     }
 
-    for (uint i = 0; i < colsol.size(); i++)
+    for (unsigned int i = 0; i < colsol.size(); i++)
     {
         if (colsol[i] < 0)
         {
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_strack_management.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_strack_management.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_strack_management.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_strack_management.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -59,12 +59,12 @@
 {
     std::set<int> existing_stracks_set;
     std::vector<STrack *> res;
-    for (uint i = 0; i < tlista.size(); i++)
+    for (unsigned int i = 0; i < tlista.size(); i++)
     {
         existing_stracks_set.insert(tlista[i].m_track_id);
         res.push_back(&tlista[i]);
     }
-    for (uint i = 0; i < tlistb.size(); i++)
+    for (unsigned int i = 0; i < tlistb.size(); i++)
     {
         int tid = tlistb[i].m_track_id;
         if (existing_stracks_set.count(tid) == 0)
@@ -92,12 +92,12 @@
 {
     std::set<int> existing_stracks_set;
     std::vector<STrack> res;
-    for (uint i = 0; i < tlista.size(); i++)
+    for (unsigned int i = 0; i < tlista.size(); i++)
     {
         existing_stracks_set.insert(tlista[i].m_track_id);
         res.push_back(tlista[i]);
     }
-    for (uint i = 0; i < tlistb.size(); i++)
+    for (unsigned int i = 0; i < tlistb.size(); i++)
     {
         int tid = tlistb[i].m_track_id;
         if (existing_stracks_set.count(tid) == 0)
@@ -124,11 +124,11 @@
 inline std::vector<STrack> JDETracker::sub_stracks(std::vector<STrack> &tlista, std::vector<STrack> &tlistb)
 {
     std::map<int, STrack> stracks;
-    for (uint i = 0; i < tlista.size(); i++)
+    for (unsigned int i = 0; i < tlista.size(); i++)
     {
         stracks.insert(std::pair<int, STrack>(tlista[i].m_track_id, tlista[i]));
     }
-    for (uint i = 0; i < tlistb.size(); i++)
+    for (unsigned int i = 0; i < tlistb.size(); i++)
     {
         int tid = tlistb[i].m_track_id;
         if (stracks.count(tid) != 0)
@@ -167,9 +167,9 @@
     std::vector<STrack> resa, resb;
     std::vector<std::vector<float>> pdist = iou_distance(stracksa, stracksb);
     std::vector<std::pair<int, int>> pairs;
-    for (uint i = 0; i < pdist.size(); i++)
+    for (unsigned int i = 0; i < pdist.size(); i++)
     {
-        for (uint j = 0; j < pdist[i].size(); j++)
+        for (unsigned int j = 0; j < pdist[i].size(); j++)
         {
             if (pdist[i][j] < IOU_THRESHOLD)
             {
@@ -179,7 +179,7 @@
     }
 
     std::vector<int> dupa, dupb;
-    for (uint i = 0; i < pairs.size(); i++)
+    for (unsigned int i = 0; i < pairs.size(); i++)
     {
         int timep = stracksa[pairs[i].first].m_frame_id - stracksa[pairs[i].first].m_start_frame;
         int timeq = stracksb[pairs[i].second].m_frame_id - stracksb[pairs[i].second].m_start_frame;
@@ -189,7 +189,7 @@
             dupa.push_back(pairs[i].first);
     }
 
-    for (uint i = 0; i < stracksa.size(); i++)
+    for (unsigned int i = 0; i < stracksa.size(); i++)
     {
         std::vector<int>::iterator iter = find(dupa.begin(), dupa.end(), i);
         if (iter == dupa.end())
@@ -198,7 +198,7 @@
         }
     }
 
-    for (uint i = 0; i < stracksb.size(); i++)
+    for (unsigned int i = 0; i < stracksb.size(); i++)
     {
         std::vector<int>::iterator iter = find(dupb.begin(), dupb.end(), i);
         if (iter == dupb.end())
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_update.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_update.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/jde_tracker_update.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/jde_tracker_update.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -31,7 +31,7 @@
 {
     std::vector<STrack> stracks_swap;
     stracks_swap.reserve(indices.size());
-    for (uint i = 0; i < indices.size(); i++)
+    for (unsigned int i = 0; i < indices.size(); i++)
     {
         if (indices[i] < (int)stracks.size())
             stracks_swap.emplace_back(stracks[indices[i]]);
@@ -52,7 +52,7 @@
 {
     std::vector<STrack *> stracks_swap;
     stracks_swap.reserve(indices.size());
-    for (uint i = 0; i < indices.size(); i++)
+    for (unsigned int i = 0; i < indices.size(); i++)
     {
         if (indices[i] < (int)stracks.size())
             stracks_swap.emplace_back(stracks[indices[i]]);
@@ -82,7 +82,7 @@
                                        std::vector<STrack> &detections,
                                        std::vector<STrack> &activated_stracks)
 {
-    for (uint i = 0; i < matches.size(); i++)
+    for (unsigned int i = 0; i < matches.size(); i++)
     {
         if ((tracked_stracks.size() == 0) || (detections.size() == 0))
             continue;
@@ -131,7 +131,7 @@
                                          std::vector<STrack> &lost_stracks,
                                          std::vector<STrack> &new_stracks)
 {
-    for (uint i = 0; i < strack_pool.size(); i++)
+    for (unsigned int i = 0; i < strack_pool.size(); i++)
     {
         STrack *track = strack_pool[i];
         switch (track->get_state())
@@ -290,7 +290,7 @@
     // Step 5: Init new stracks
     //******************************************************************
     // At this point, any leftover unmatched new detections are considered new object instances for tracking
-    for (uint i = 0; i < unmatched_detections.size(); i++)
+    for (unsigned int i = 0; i < unmatched_detections.size(); i++)
         new_stracks.emplace_back(detections[unmatched_detections[i]]);
 
     //******************************************************************
@@ -306,18 +306,18 @@
     //******************************************************************
     std::vector<STrack> output_stracks;
     output_stracks.reserve(this->m_tracked_stracks.size());
-    for (uint i = 0; i < this->m_tracked_stracks.size(); i++)
+    for (unsigned int i = 0; i < this->m_tracked_stracks.size(); i++)
         output_stracks.emplace_back(this->m_tracked_stracks[i]);
 
     // Include unconfirmed detections if requested
     if (report_unconfirmed or this->m_debug)
     {
-        for (uint i = 0; i < this->m_new_stracks.size(); i++)
+        for (unsigned int i = 0; i < this->m_new_stracks.size(); i++)
             output_stracks.emplace_back(this->m_new_stracks[i]);
     }
     if (report_lost or this->m_debug)
     {
-        for (uint i = 0; i < this->m_lost_stracks.size(); i++)
+        for (unsigned int i = 0; i < this->m_lost_stracks.size(); i++)
             output_stracks.emplace_back(this->m_lost_stracks[i]);
     }
     return output_stracks;
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/kalman_filter.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/kalman_filter.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/kalman_filter.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/kalman_filter.hpp	2025-11-01 12:19:56.209854830 +0800
@@ -123,17 +123,17 @@
 
         int sum = 0;
         // Decomposing a matrix into Lower Triangular
-        for (uint i = 0; i < matrix.shape(0); i++) {
-            for (uint j = 0; j <= i; j++) {
+        for (unsigned int i = 0; i < matrix.shape(0); i++) {
+            for (unsigned int j = 0; j <= i; j++) {
                 sum = 0;
                 if (j == i) // summation for diagonals
                 {
-                    for (uint k = 0; k < j; k++)
+                    for (unsigned int k = 0; k < j; k++)
                         sum += std::pow(lower_matrix(j, k), 2);
                     lower_matrix(j,j) = std::sqrt(matrix(j,j) - sum);
                 } else {
                     // Evaluating L(i, j) using L(j, j)
-                    for (uint k = 0; k < j; k++)
+                    for (unsigned int k = 0; k < j; k++)
                         sum += lower_matrix(i, k) * lower_matrix(j, k);
                     lower_matrix(i, j) = (matrix(i, j) - sum) / lower_matrix(j, j);
                 }
@@ -320,7 +320,7 @@
     xt::xarray<float, xt::layout_type::row_major> mat_mul_2D(xt::xarray<float, xt::layout_type::row_major> matrix_1,
                                                              xt::xarray<float, xt::layout_type::row_major> matrix_2)
     {
-        uint axis_length = matrix_1.shape(1);
+        unsigned int axis_length = matrix_1.shape(1);
         if (axis_length != matrix_2.shape(0))
         {
             throw std::invalid_argument("mat_mul_2D broadcast error: axis don't match!");
@@ -329,12 +329,12 @@
         float row_sum;
         xt::xarray<float>::shape_type shape = {matrix_1.shape(0), matrix_2.shape(1)};
         xt::xarray<float, xt::layout_type::row_major> product_matrix(shape);
-        for (uint i = 0; i < matrix_1.shape(0); ++i)
+        for (unsigned int i = 0; i < matrix_1.shape(0); ++i)
         {
-            for (uint j = 0; j < matrix_2.shape(1); ++j)
+            for (unsigned int j = 0; j < matrix_2.shape(1); ++j)
             {
                 row_sum = 0.0;
-                for (uint k = 0; k < matrix_1.shape(1); ++k)
+                for (unsigned int k = 0; k < matrix_1.shape(1); ++k)
                 {
                     row_sum += matrix_1(i, k) * matrix_2(k, j);
                 }
@@ -523,7 +523,7 @@
         
         // DETECTBOXSS differs from DETECTBOX in that DETECTBOXSS is Nx4 instead of 1x4
         TrackerTypes::DETECTBOXSS d = xt::zeros<float>({(int)measurements.size(), 4});
-        for (uint i = 0; i < measurements.size(); ++i)
+        for (unsigned int i = 0; i < measurements.size(); ++i)
         {
             xt::row(d, i) = xt::squeeze(measurements[i] - mean1);
         }
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/python_bindings/jde_tracker_pybind.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/python_bindings/jde_tracker_pybind.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/python_bindings/jde_tracker_pybind.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/python_bindings/jde_tracker_pybind.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -95,7 +95,7 @@
         std::vector<HailoDetectionPtr> converted_detections = numpy_to_detections(input_detections);
         std::vector<STrack> online_stracks = m_jde_tracker->update(converted_detections, report_unconfirmed);
         std::vector<STrackWrapper> output_pystracks(online_stracks.size());
-        for (uint i = 0; i < online_stracks.size(); i++)
+        for (unsigned int i = 0; i < online_stracks.size(); i++)
         {
             auto strack = std::make_unique<STrack>(online_stracks[i]);
             output_pystracks[i] = STrackWrapper(std::move(strack));
diff -Naur tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/strack.hpp tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/strack.hpp
--- tappas-5.1.0.orig/core/hailo/tracking/jde_tracker/strack.hpp	2025-09-30 18:22:58.000000000 +0800
+++ tappas-5.1.0.mod/core/hailo/tracking/jde_tracker/strack.hpp	2025-11-01 12:19:56.205854831 +0800
@@ -305,7 +305,7 @@
      */
     static void multi_predict(std::vector<STrack *> &stracks, KalmanFilter &kalman_filter)
     {
-        for (uint i = 0; i < stracks.size(); i++)
+        for (unsigned int i = 0; i < stracks.size(); i++)
         {
             if (stracks[i]->m_state != TrackState::Tracked)
             {
@@ -438,7 +438,7 @@
     {
         cv::Mat feat_mat(feat);
         float feat_value = cv::norm(feat_mat);
-        for (uint i = 0; i < feat.size(); ++i)
+        for (unsigned int i = 0; i < feat.size(); ++i)
         {
             feat[i] /= feat_value;
         }
@@ -449,7 +449,7 @@
         }
         else
         {
-            for (uint i = 0; i < this->m_smooth_feat.size(); ++i)
+            for (unsigned int i = 0; i < this->m_smooth_feat.size(); ++i)
             {
                 this->m_smooth_feat[i] = m_alpha * this->m_smooth_feat[i] + (1 - m_alpha) * feat[i];
             }
@@ -457,7 +457,7 @@
 
         cv::Mat smooth_feat_mat(this->m_smooth_feat);
         float smmoth_feat_value = cv::norm(smooth_feat_mat);
-        for (uint i = 0; i < this->m_smooth_feat.size(); ++i)
+        for (unsigned int i = 0; i < this->m_smooth_feat.size(); ++i)
         {
             this->m_smooth_feat[i] /= smmoth_feat_value;
         }
